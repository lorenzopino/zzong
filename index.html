<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Songwriting Game</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <style>
        /* Existing styles */
        body { background-color: #f8f9fa; }
        .phase-title { margin-bottom: 1.5rem; color: #6c757d; }
        .step-card { margin-bottom: 1.5rem; }
        .list-group-item span, .layer-suggestion span, .structure-display span, .progression-display span, .length-display span, .arrangement-value span { font-weight: bold; color: #fd5f00; }
        .layer-suggestion { font-size: 1.1rem; margin-bottom: 1rem; }
        .previous-layers { margin-top: 1.5rem; font-size: 0.9rem; }
        .previous-layers .badge { margin-right: 5px; }
        .btn { margin-top: 0.5rem; }
        .structure-sequence .badge { font-size: 1rem; margin: 2px; padding: 0.5em 0.7em; }
        .section-roles { font-size: 0.9em; color: #6c757d; }
        .chord-progression { font-family: monospace; font-size: 1.1em; }
        /* Phase 3 Styles */
        .arrangement-step {
            padding: 1rem;
            border-left: 3px solid #dee2e6; /* Light grey border */
            margin-bottom: 1rem;
        }
        .arrangement-step.active {
            border-left-color: #fd5f00; /* Accent color border */
            background-color: #fff;
        }
         .arrangement-step.completed {
             border-left-color: #198754; /* Green border for completed */
             opacity: 0.8;
         }
        .arrangement-step h6 {
            margin-bottom: 0.75rem;
            color: #495057;
        }
        .initial-layers-list li {
            font-size: 0.9em;
        }
         .variation-prompt { font-style: italic; }
    </style>
</head>
<body>

    <div id="app" class="container mt-4 mb-5">
        <h1 class="mb-3">The Songwriting Game</h1>
        <hr>

        <div v-if="currentPhase < 3">
            <h2 class="phase-title">Setup Phases <button class="btn btn-sm btn-outline-secondary float-end" @click="skipToPhase3Debug">Skip to Phase 3 (Debug)</button></h2>
             <p>Complete Phase 1 (Context & Layers) and Phase 2 (Structure Map) first.</p>
             <div v-if="currentPhase === 1 && currentStep === '1.post'">Phase 1 Complete. Ready for Phase 2. <button class="btn btn-sm btn-info" @click="startPhase2">Start Phase 2</button></div>
              <div v-if="currentPhase === 2 && currentStep === 2.3 && structure.lengthsConfirmed">Phase 2 Complete. Ready for Phase 3. <button class="btn btn-sm btn-info" @click="startPhase3">Start Phase 3</button></div>
        </div>


        <div v-if="currentPhase === 3">
            <h2 class="phase-title">Phase 3: Arrangement Forge</h2>

            <div class="card step-card">
                <div class="card-body">
                    <div v-if="currentArrangementInstance">
                        <h5 class="card-title">Arranging Section {{ currentArrangementIndex + 1 }} / {{ structure.templateSequence.length }}</h5>
                        <h4>
                            {{ currentArrangementInstance.displayName }}
                            <small class="text-muted">({{ currentArrangementInstance.sectionLetter }}, Instance {{ currentArrangementInstance.instanceNumber }})</small>
                        </h4>
                        <p><strong>Length:</strong> {{ currentArrangementInstance.length }} bars | <strong>Progression:</strong> <code class="chord-progression">{{ currentArrangementInstance.progression }}</code></p>
                        <hr>

                         <div>
                            <div class="arrangement-step" :class="{ active: !currentInstanceLogEntry.adaptationConfirmed, completed: currentInstanceLogEntry.adaptationConfirmed }">
                                <h6>Step 3.2: Harmonic Adaptation</h6>
                                <div v-if="!currentInstanceLogEntry.adaptationConfirmed">
                                    <p v-if="currentArrangementInstance.progression === currentArrangementInstance.previousProgression && currentArrangementIndex > 0">
                                        Progression is the same as the previous section. Focus on arrangement variations below.
                                    </p>
                                    <p v-else-if="currentArrangementIndex === 0 || currentArrangementInstance.progression !== currentArrangementInstance.previousProgression">
                                        <span v-if="currentArrangementIndex === 0">Use your initial 4 layers as the basis for this first section.</span>
                                        <span v-else>Progression changed! Adapt your core harmonic/melodic layers to fit: <code class="chord-progression">{{ currentArrangementInstance.progression }}</code></span>
                                        <br>Focus on layers like:
                                        <ul class="mt-2 initial-layers-list">
                                            <li v-for="layer in layers">{{ layer.modifier }} {{ layer.type }}</li>
                                        </ul>
                                    </p>
                                     <button class="btn btn-success btn-sm" @click="confirmAdaptation">
                                         {{ (currentArrangementInstance.progression === currentArrangementInstance.previousProgression && currentArrangementIndex > 0) ? 'Continue to Variations' : 'Confirm Layers Adapted / Applied' }}
                                     </button>
                                </div>
                                <div v-else>
                                    <p class="text-success"><small>Adaptation Confirmed.</small></p>
                                </div>
                             </div>

                             <div class="arrangement-step" :class="{ active: currentInstanceLogEntry.adaptationConfirmed && !currentInstanceLogEntry.variationsConfirmed, completed: currentInstanceLogEntry.variationsConfirmed, 'd-none': !currentInstanceLogEntry.adaptationConfirmed }">
                                 <h6>Step 3.3: Arrangement Variations</h6>
                                 <div v-if="!currentInstanceLogEntry.variationsConfirmed">
                                     <div v-if="!currentInstanceLogEntry.density"> <p>Ready to add unique character to this section?</p>
                                         <button class="btn btn-primary btn-sm" @click="suggestVariations">Suggest Variations</button>
                                     </div>
                                     <div v-else> <p>Suggestions:</p>
                                         <ul class="list-unstyled">
                                             <li><strong>Density:</strong> <span class="arrangement-value">{{ currentInstanceLogEntry.density }}</span></li>
                                             <li v-for="(prompt, pIdx) in currentInstanceLogEntry.variations" :key="pIdx">
                                                 <strong>Prompt {{ pIdx + 1 }}:</strong> <span class="variation-prompt">{{ prompt }}</span>
                                             </li>
                                         </ul>
                                         <button class="btn btn-success btn-sm me-2" @click="confirmVariations">Confirm Variations Implemented</button>
                                         <button class="btn btn-secondary btn-sm" @click="suggestVariations">Regenerate Suggestions</button>
                                     </div>
                                 </div>
                                 <div v-else>
                                     <p class="text-success"><small>Variations Confirmed.</small></p>
                                 </div>
                             </div>

                            <div class="arrangement-step"
                                  :class="{ active: currentInstanceLogEntry.variationsConfirmed && !currentInstanceLogEntry.transitionConfirmed && !isLastSection,
                                             completed: currentInstanceLogEntry.transitionConfirmed,
                                            'd-none': !currentInstanceLogEntry.variationsConfirmed || isLastSection }">
                                 <h6>Step 3.4: Transition Out</h6>
                                 <div v-if="!currentInstanceLogEntry.transitionConfirmed">
                                      <div v-if="!currentInstanceLogEntry.transition">
                                          <p>How should this section transition to the next?</p>
                                          <button class="btn btn-primary btn-sm" @click="suggestTransition">Suggest Transition</button>
                                      </div>
                                       <div v-else>
                                           <p>Suggested Transition: <span class="arrangement-value">{{ currentInstanceLogEntry.transition }}</span></p>
                                           <button class="btn btn-success btn-sm me-2" @click="confirmTransition">Confirm Transition Implemented</button>
                                           <button class="btn btn-secondary btn-sm" @click="suggestTransition">Regenerate Suggestion</button>
                                       </div>
                                 </div>
                                 <div v-else>
                                     <p class="text-success"><small>Transition Confirmed.</small></p>
                                 </div>
                             </div>
                              <div class="arrangement-step" v-if="isLastSection && currentInstanceLogEntry.variationsConfirmed">
                                   <h6>Step 3.4: Transition Out</h6>
                                   <p><small>N/A (Last Section)</small></p>
                              </div>


                            <div class="mt-4 text-center">
                                <button class="btn btn-info" @click="completeCurrentInstance"
                                        :disabled="!canCompleteInstance">
                                   {{ isLastSection ? 'Complete Final Section & Proceed to Polish' : 'Complete Section & Move to Next' }}
                                </button>
                             </div>

                         </div> </div> <div v-else>
                         <p class="alert alert-warning">Loading arrangement data...</p>
                     </div>
                </div> </div> </div> <div v-if="currentPhase === 4">
             <h2 class="phase-title">Phase 4: Final Polish (Work in Progress)</h2>
              <div class="card step-card">
                  <div class="card-body">
                       <p>Structured final review with guided checks.</p>
                       <button class="btn btn-secondary" @click="goBackToPhase3">Back (Debug)</button>
                  </div>
              </div>
         </div> </div> <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>

    <script>
        const { createApp, ref, reactive, computed } = Vue;

        createApp({
            data() {
                return {
                    // --- Core State ---
                    currentPhase: 1,
                    currentStep: 1.1, // Or 2.1, 3.1 etc.
                    framework: reactive({ key: null, scale: null, tempo: null }),
                    contextConfirmed: false, // Simplified context flags
                    // --- Phase 1 State ---
                    currentLayerIndex: 0,
                    layers: reactive([]), // { id, type, modifier, confirmed } - Simplified
                    // --- Phase 2 State ---
                    structure: reactive({
                        templateName: null,
                        templateSequence: [],
                        progressions: { A: null }, // { A: 'pattern', B: 'pattern', ... }
                        lengths: {}, // { A: 16, B: 12, ... }
                        templateConfirmed: false, // Simplified flags
                        lengthsConfirmed: false,
                    }),
                    // No longer need separate flags for Phase 2 steps, infer from state
                    // --- Phase 3 State ---
                    currentArrangementIndex: -1, // Index for structure.templateSequence (0 to N-1)
                    arrangementLog: reactive({}), // Map: { 'A-1': { log data }, 'B-1': { log data } ... }

                    // --- Data Lists ---
                    musicalKeys: [ /* ... */ 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
                    musicalScales: [ /* ... (with 'type') ... */ { name: 'Major', type: 'major', definition: '...' }, { name: 'Natural Minor', type: 'minor', definition: '...' }, /* etc */ ],
                    instrumentTypes: [ /* ... */ 'Foundation Rhythm', 'Groove Bass', 'Main Chords', /* etc */ ],
                    stylisticModifiers: [ /* ... */ 'Filtered', 'Reverby/Dreamy', 'Wobbly/Detuned', /* etc */ ],
                    tempoRange: { min: 70, max: 125 },
                    structureTemplates: [ /* ... (10 templates) ... */ { name: 'Simple A/B Repeat', sequence: ['A', 'B', 'A', 'B'] }, /* etc */ ],
                    commonProgressions: { major: [/*...*/], minor: [/*...*/] },
                    // Phase 3 Data Lists
                    densityOptions: ['Sparse', 'Medium', 'Dense'], // Used for d6 mapping
                    variationPromptOptions: [ // Simple list for prototype
                        "Simplify one layer's rhythm.",
                        "Add filter movement (sweep/cutoff change) to one layer.",
                        "Introduce a subtle background texture/FX.",
                        "Double the main rhythm element (e.g., kick or snare) briefly.",
                        "Drop out the bass for the first 2 bars.",
                        "Make the main chord layer more staccato.",
                        "Add a simple counter-melody element.",
                        "Use automation on panning or volume for one layer.",
                        "Introduce a delay throw on one element.",
                        "Slightly detune a melodic element."
                    ],
                    transitionTypes: [ // From Spec
                        'Drop Out', 'Filter Sweep Out', 'Rhythmic Fill', 'Sustained Element',
                        'FX Swell/Riser', 'Abrupt Cut', 'Delayed Echo Out', 'Silence Gap (1 beat)'
                    ],

                }
            },
            computed: {
                // --- Phase 3 Computed Properties ---
                currentArrangementInstance() {
                    if (this.currentPhase !== 3 || this.currentArrangementIndex < 0 || this.currentArrangementIndex >= this.structure.templateSequence.length) {
                        return null; // Not in Phase 3 or index invalid
                    }
                    const index = this.currentArrangementIndex;
                    const sectionLetter = this.structure.templateSequence[index];
                    const instanceNumber = this.calculateInstanceNumber(index, sectionLetter);
                    const progression = this.structure.progressions[sectionLetter] || 'N/A';
                    const length = this.structure.lengths[sectionLetter] || 'N/A';
                    const logKey = this.getInstanceLogKey(index); // e.g., 'A-1'

                    // Determine previous progression safely
                    let previousProgression = null;
                    if (index > 0) {
                         const prevSectionLetter = this.structure.templateSequence[index - 1];
                         previousProgression = this.structure.progressions[prevSectionLetter] || 'N/A';
                    }

                    // Create a display name (e.g., Verse 1, Chorus 1, Verse 2)
                    let baseName = 'Section';
                    if (sectionLetter === 'A') baseName = 'Verse'; // Example mapping
                    else if (sectionLetter === 'B') baseName = 'Chorus';
                    else if (sectionLetter === 'C') baseName = 'Bridge';
                    else if (sectionLetter === 'Intro') baseName = 'Intro';
                    else if (sectionLetter === 'Outro') baseName = 'Outro';
                    else if (sectionLetter === 'Instrumental') baseName = 'Instrumental';
                    else if (sectionLetter.endsWith('+')) baseName = 'Variation'; // A+, B+

                    const displayName = `${baseName} ${instanceNumber}`;


                    return {
                        index: index,
                        logKey: logKey,
                        sectionLetter: sectionLetter,
                        instanceNumber: instanceNumber,
                        displayName: displayName,
                        progression: progression,
                        length: length,
                        previousProgression: previousProgression
                    };
                },
                currentInstanceLogEntry() {
                     if (!this.currentArrangementInstance) return {};
                     // Return the log entry for the current instance, ensuring it exists
                     const key = this.currentArrangementInstance.logKey;
                     if (!this.arrangementLog[key]) {
                          // Initialize if missing (should be done when index advances)
                          this.initializeLogEntry(key);
                     }
                     return this.arrangementLog[key];
                },
                 isLastSection() {
                     if (this.currentPhase !== 3 || !this.structure.templateSequence) return false;
                     return this.currentArrangementIndex === this.structure.templateSequence.length - 1;
                 },
                 canCompleteInstance() {
                     if (!this.currentArrangementInstance || !this.currentInstanceLogEntry) return false;
                     const logEntry = this.currentInstanceLogEntry;
                     const transitionNeeded = !this.isLastSection;

                     return logEntry.adaptationConfirmed &&
                            logEntry.variationsConfirmed &&
                            (logEntry.transitionConfirmed || !transitionNeeded);
                 }

            },
            methods: {
                // --- Helpers --- (getRandomInt, getRandomElement, getScale*, etc) - Assume exist
                 getRandomInt(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1)) + min; },
                 getRandomElement(arr) { if (!arr || arr.length === 0) return null; const randomIndex = Math.floor(Math.random() * arr.length); return arr[randomIndex]; },
                 // ... other helpers ...

                // --- Phase Navigation ---
                startPhase2() { /* ... */ this.currentPhase = 2; this.currentStep = 2.1; },
                startPhase3() {
                    if (this.currentPhase === 2 && this.structure.lengthsConfirmed) {
                        this.currentPhase = 3;
                        this.currentStep = 3.1; // Indicate phase start
                        this.currentArrangementIndex = 0; // Start at the first section instance
                        this.initializeLogEntry(this.getInstanceLogKey(0)); // Initialize log for the first instance
                        console.log("Moving to Phase 3, starting arrangement.");
                    }
                 },
                 startPhase4() {
                      this.currentPhase = 4;
                      this.currentStep = 4.1; // First step of Phase 4
                      console.log("Moving to Phase 4: Final Polish");
                 },

                // --- Phase 3 Methods ---
                getInstanceLogKey(index) {
                     if (index < 0 || index >= this.structure.templateSequence.length) return null;
                     const sectionLetter = this.structure.templateSequence[index];
                     const instanceNumber = this.calculateInstanceNumber(index, sectionLetter);
                     return `${sectionLetter}-${instanceNumber}`; // e.g., A-1, B-1, A-2
                },
                 calculateInstanceNumber(targetIndex, sectionLetter) {
                     let count = 0;
                     for (let i = 0; i <= targetIndex; i++) {
                         if (this.structure.templateSequence[i] === sectionLetter) {
                             count++;
                         }
                     }
                     return count;
                 },
                 initializeLogEntry(key) {
                      if (key && !this.arrangementLog[key]) {
                           console.log("Initializing log entry for:", key);
                           this.arrangementLog[key] = reactive({
                                adaptationConfirmed: false,
                                density: null,
                                variations: [],
                                variationsConfirmed: false,
                                transition: null,
                                transitionConfirmed: false
                           });
                      }
                 },
                 // Step 3.2 Method
                 confirmAdaptation() {
                      if (!this.currentArrangementInstance) return;
                      const key = this.currentArrangementInstance.logKey;
                      console.log(`Adaptation confirmed for ${key}`);
                      this.arrangementLog[key].adaptationConfirmed = true;
                 },
                 // Step 3.3 Methods
                 suggestVariations() {
                      if (!this.currentArrangementInstance) return;
                      const key = this.currentArrangementInstance.logKey;
                      console.log(`Suggesting variations for ${key}`);

                      // Density (d6 roll)
                      const densityRoll = this.getRandomInt(1, 6);
                      if (densityRoll <= 2) this.arrangementLog[key].density = 'Sparse';
                      else if (densityRoll <= 4) this.arrangementLog[key].density = 'Medium';
                      else this.arrangementLog[key].density = 'Dense';

                       // Variation Prompts (1 or 2)
                       const numPrompts = this.getRandomInt(1, 4) <= 2 ? 1 : 2; // d4: 1-2=1 prompt, 3-4=2 prompts
                       const selectedPrompts = [];
                       // Simple random selection (could be smarter later)
                       let availablePrompts = [...this.variationPromptOptions];
                       for (let i = 0; i < numPrompts; i++) {
                            if (availablePrompts.length === 0) break;
                            const randomIndex = Math.floor(Math.random() * availablePrompts.length);
                            selectedPrompts.push(availablePrompts.splice(randomIndex, 1)[0]);
                       }
                       this.arrangementLog[key].variations = selectedPrompts;
                       this.arrangementLog[key].variationsConfirmed = false; // Reset confirmation on regenerate
                       console.log("Density:", this.arrangementLog[key].density);
                       console.log("Variations:", this.arrangementLog[key].variations);
                 },
                 confirmVariations() {
                      if (!this.currentArrangementInstance || !this.arrangementLog[this.currentArrangementInstance.logKey]?.density) return;
                      const key = this.currentArrangementInstance.logKey;
                      console.log(`Variations confirmed for ${key}`);
                      this.arrangementLog[key].variationsConfirmed = true;
                 },
                 // Step 3.4 Methods
                 suggestTransition() {
                     if (!this.currentArrangementInstance || this.isLastSection) return;
                     const key = this.currentArrangementInstance.logKey;
                     console.log(`Suggesting transition for ${key}`);
                     this.arrangementLog[key].transition = this.getRandomElement(this.transitionTypes);
                     this.arrangementLog[key].transitionConfirmed = false; // Reset confirmation
                     console.log("Transition:", this.arrangementLog[key].transition);
                 },
                 confirmTransition() {
                     if (!this.currentArrangementInstance || !this.arrangementLog[this.currentArrangementInstance.logKey]?.transition) return;
                     const key = this.currentArrangementInstance.logKey;
                     console.log(`Transition confirmed for ${key}`);
                     this.arrangementLog[key].transitionConfirmed = true;
                 },
                 // Step 3.5 Method
                 completeCurrentInstance() {
                     if (!this.canCompleteInstance) {
                          console.warn("Cannot complete instance yet, check confirmations.");
                          return;
                     }
                      console.log(`Completing arrangement for instance ${this.currentArrangementIndex + 1}`);

                      const nextIndex = this.currentArrangementIndex + 1;
                      if (nextIndex < this.structure.templateSequence.length) {
                           // Move to next instance
                           this.currentArrangementIndex = nextIndex;
                           this.initializeLogEntry(this.getInstanceLogKey(nextIndex)); // Ensure log entry exists for next step
                           console.log("Moving to next instance:", this.currentArrangementIndex + 1);
                           // Reset scroll or focus if needed UI-wise
                           window.scrollTo(0, 0);
                      } else {
                           // All instances done, move to Phase 4
                           console.log("Arrangement Forge Complete!");
                           this.startPhase4();
                      }
                 },

                // --- Debug/Nav Helpers ---
                skipToPhase3Debug() { /* ... */
                    // Simulate previous phases being done with some data
                     this.framework = reactive({ key: 'A', scale: 'Major', tempo: 110 });
                     this.layers = reactive([ { id: 1, type: 'Rhythm', modifier: 'Dry', confirmed: true }, /* ... 3 more */ ]);
                     this.structure = reactive({
                          templateName: 'Classic Structure',
                          templateSequence: ['Intro', 'A', 'B', 'A', 'B', 'Outro'],
                          progressions: { A: 'I-V-vi-IV', B: 'vi-IV-I-V', Intro: 'IV-I', Outro: 'I-V' },
                          lengths: { A: 16, B: 12, Intro: 8, Outro: 8 },
                          templateConfirmed: true, lengthsConfirmed: true,
                     });
                     this.arrangementLog = reactive({}); // Clear log
                     this.startPhase3();
                },
                 goBackToPhase2Lengths() { /* ... */ this.currentPhase = 2; this.currentStep = 2.3; },
                 goBackToPhase3() { /* ... */ this.currentPhase = 3; this.currentStep = 3.1; /* May need more logic to restore exact step */ }

            },
            mounted() {
                console.log("Vue App Mounted!");
                // You might want to load state from localStorage here in a real app
            }
        }).mount('#app');
    </script>

</body>
</html>