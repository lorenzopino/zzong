<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Songwriting Game</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <style>
        /* Existing styles from your working version */
        body { background-color: #f8f9fa; }
        .phase-title { margin-bottom: 1.5rem; color: #6c757d; }
        .step-card { margin-bottom: 1.5rem; }
        .list-group-item span, .layer-suggestion span, .structure-display span, .progression-display span, .length-display span { font-weight: bold; color: #fd5f00; }
        .layer-suggestion { font-size: 1.1rem; margin-bottom: 1rem; }
        .previous-layers { margin-top: 1.5rem; font-size: 0.9rem; }
        .previous-layers .badge { margin-right: 5px; }
        .btn { margin-top: 0.5rem; }
        /* New styles for Phase 2 from previous attempt */
        .structure-sequence .badge { font-size: 1rem; margin: 2px; padding: 0.5em 0.7em; }
        .section-roles { font-size: 0.9em; color: #6c757d; }
        .chord-progression { font-family: monospace; font-size: 1.1em; }
    </style>
</head>
<body>

    <div id="app" class="container mt-4 mb-5">
        <h1 class="mb-3">The Songwriting Game</h1>
        <hr>

        <div v-if="currentPhase === 1">
            <h2 class="phase-title">Phase 1: Sonic Core Definition</h2>

            <div class="card step-card" v-if="currentStep === 1.1">
                <div class="card-body">
                    <h5 class="card-title">Step 1.1: Generate Musical Context</h5>
                    <div v-if="!contextGenerated && !contextConfirmed">
                        <p>Let's define the musical foundation for your track.</p>
                        <button class="btn btn-primary" @click="generateContext">Generate Key, Scale & Tempo</button>
                    </div>
                    <div v-if="contextGenerated && !contextConfirmed">
                        <p>Here's the suggested musical context:</p>
                        <ul class="list-group mb-3">
                            <li class="list-group-item">Key: <span>{{ framework.key }}</span></li>
                            <li class="list-group-item">Scale/Mode: <span>{{ framework.scale }}</span> <small>({{ getScaleDefinition(framework.scale) }})</small></li>
                            <li class="list-group-item">Tempo: <span>{{ framework.tempo }} BPM</span></li>
                        </ul>
                        <button class="btn btn-success me-2" @click="confirmContext">Confirm Context</button>
                        <button class="btn btn-secondary" @click="generateContext">Generate Again</button>
                    </div>
                    <div v-if="contextConfirmed">
                        <p class="alert alert-success">Musical context confirmed: <strong>{{ framework.key }} {{ framework.scale }}</strong> at <strong>{{ framework.tempo }} BPM</strong>.</p>
                        <button class="btn btn-info" @click="startLayerGeneration">Start Creating Layer 1</button>
                    </div>
                </div>
            </div>

            <div class="card step-card" v-if="currentStep === 1.2">
                <div class="card-body">
                    <h5 class="card-title">Step 1.2: Create Initial Layers ({{ currentLayerIndex }} / 4)</h5>
                    <p><strong>Context:</strong> {{ framework.key }} {{ framework.scale }}, {{ framework.tempo }} BPM</p>
                    <hr>
                    <div v-if="layers[currentLayerIndex - 1]">
                        <div v-if="!layers[currentLayerIndex - 1].suggested">
                            <p>Ready to create <strong>Layer {{ currentLayerIndex }}</strong>?</p>
                            <button class="btn btn-primary" @click="generateLayerSuggestion(currentLayerIndex)">Generate Suggestion for Layer {{ currentLayerIndex }}</button>
                        </div>
                        <div v-if="layers[currentLayerIndex - 1].suggested && !layers[currentLayerIndex - 1].confirmed">
                            <p>Suggestion for <strong>Layer {{ currentLayerIndex }}</strong>:</p>
                            <p class="alert alert-info layer-suggestion">Create a <span>{{ layers[currentLayerIndex - 1].modifier }}</span> <span>{{ layers[currentLayerIndex - 1].type }}</span>.</p>
                            <button class="btn btn-success" @click="confirmLayerCreated(currentLayerIndex)">Confirm Layer {{ currentLayerIndex }} Created</button>
                            <button class="btn btn-secondary ms-2" @click="generateLayerSuggestion(currentLayerIndex)">Regenerate Suggestion</button>
                        </div>
                    </div>
                    <div class="previous-layers" v-if="getConfirmedLayers().length > 0">
                        <h6>Confirmed Layers:</h6>
                        <p><span v-for="layer in getConfirmedLayers()" :key="layer.id" class="badge bg-secondary text-light">L{{ layer.id }}: {{ layer.modifier }} {{ layer.type }}</span></p>
                    </div>
                </div>
            </div>

            <div class="card step-card" v-if="currentStep === '1.post'">
                <div class="card-body">
                    <h5 class="card-title">Sonic Core Complete!</h5>
                    <p class="alert alert-success">All 4 initial layers created.</p>
                    <p>Suggested initial chord progression (Progression A):</p>
                    <p class="alert alert-info progression-display"><strong>Progression A:</strong> <span class="chord-progression">{{ structure.progressions.A }}</span></p>
                    <button class="btn btn-info" @click="startPhase2">Proceed to Phase 2: Structure Map</button>
                </div>
            </div>
        </div> <div v-if="currentPhase === 2">
            <h2 class="phase-title">Phase 2: Structure Map Definition</h2>

            <div class="card step-card" v-if="currentStep === 2.1">
                <div class="card-body">
                    <h5 class="card-title">Step 2.1: Generate Structure Template</h5>
                    <div v-if="!structure.templateGenerated">
                        <p>Let's choose a structure for your song.</p>
                        <button class="btn btn-primary" @click="generateStructureTemplate">Generate Structure Template</button>
                    </div>
                    <div v-if="structure.templateGenerated && !structure.templateConfirmed">
                        <p>Suggested Structure Template:</p>
                        <div class="structure-display mb-3">
                            <h6>Name: <span>{{ structure.templateName }}</span></h6>
                            <p>Sequence:</p>
                            <p class="structure-sequence">
                                <span v-for="(section, index) in structure.templateSequence" :key="index" class="badge bg-dark">{{ section }}</span>
                            </p>
                            <p class="section-roles"><small>Typical Roles: A=Verse/Main, B=Chorus/Contrast, C=Bridge/Development, Intro/Outro=Bookends, +/- = Variation</small></p>
                        </div>
                        <button class="btn btn-success me-2" @click="confirmStructureTemplate">Confirm Structure</button>
                        <button class="btn btn-secondary" @click="generateStructureTemplate">Regenerate Structure</button>
                    </div>
                    <div v-if="structure.templateConfirmed">
                        <p class="alert alert-success">Structure Template confirmed: <strong>{{ structure.templateName }}</strong></p>
                        <p v-if="sectionsToDefineHarmony.length > 0">Next, we need to define the harmony for new section types: {{ sectionsToDefineHarmony.join(', ') }}.</p>
                        <p v-else>All sections use Progression A. Proceed to define lengths.</p>
                        <button class="btn btn-info" @click="startHarmonyDefinition">
                            {{ sectionsToDefineHarmony.length > 0 ? 'Define Harmony' : 'Define Section Lengths' }}
                        </button>
                    </div>
                </div>
            </div> <div class="card step-card" v-if="currentStep === 2.2">
                <div class="card-body">
                    <h5 class="card-title">Step 2.2: Define Harmony ({{ currentSectionIndexToDefine + 1 }} / {{ sectionsToDefineHarmony.length }})</h5>
                    <div v-if="currentSectionLetterToDefine">
                        <p>Define harmony for Section Type: <strong style="font-size: 1.5em;">'{{ currentSectionLetterToDefine }}'</strong></p>
                        <p>Reference - Progression A: <code class="chord-progression">{{ structure.progressions.A }}</code></p>
                        <div v-if="!structure.progressions[currentSectionLetterToDefine]">
                            <button class="btn btn-primary" @click="generateHarmonyForSection(currentSectionLetterToDefine)">Generate Harmony Suggestion for '{{ currentSectionLetterToDefine }}'</button>
                        </div>
                        <div v-if="structure.progressions[currentSectionLetterToDefine] && !harmonyConfirmed[currentSectionLetterToDefine]">
                            <p>Suggested harmony pattern for Section '{{ currentSectionLetterToDefine }}':</p>
                            <p class="alert alert-info progression-display">
                                <strong>Progression {{ currentSectionLetterToDefine }}:</strong>
                                <span class="chord-progression">{{ structure.progressions[currentSectionLetterToDefine] }}</span>
                                <br><small>(Roman numeral pattern placeholder based on {{ framework.key }} {{ framework.scale }})</small>
                            </p>
                            <button class="btn btn-success me-2" @click="confirmHarmony(currentSectionLetterToDefine)">Confirm Harmony for '{{ currentSectionLetterToDefine }}'</button>
                            <button class="btn btn-secondary" @click="generateHarmonyForSection(currentSectionLetterToDefine)">Regenerate Suggestion</button>
                        </div>
                        <div v-if="harmonyConfirmed[currentSectionLetterToDefine]">
                            </div>
                    </div>
                    <div v-else>
                        <p class="alert alert-success">All required section harmonies defined!</p>
                        <button class="btn btn-info" @click="startLengthDefinition">Next: Define Section Lengths</button>
                    </div>
                </div>
            </div> <div class="card step-card" v-if="currentStep === 2.3">
                <div class="card-body">
                    <h5 class="card-title">Step 2.3: Define Section Lengths</h5>
                    <div v-if="!structure.lengthsGenerated">
                        <p>Let's determine the length (in bars) for each unique section type.</p>
                        <button class="btn btn-primary" @click="generateSectionLengths">Generate Section Lengths</button>
                    </div>
                    <div v-if="structure.lengthsGenerated && !structure.lengthsConfirmed">
                        <p>Suggested Section Lengths:</p>
                        <ul class="list-group mb-3">
                            <li v-for="(length, section) in structure.lengths" :key="section" class="list-group-item length-display">
                                Section <strong>'{{ section }}'</strong>: <span>{{ length }} bars</span>
                            </li>
                        </ul>
                        <button class="btn btn-success me-2" @click="confirmSectionLengths">Confirm Lengths</button>
                        <button class="btn btn-secondary" @click="generateSectionLengths">Regenerate Lengths</button>
                    </div>
                    <div v-if="structure.lengthsConfirmed">
                        <p class="alert alert-success">Structure Map fully defined!</p>
                        <button class="btn btn-info" @click="startPhase3">Proceed to Phase 3: Arrangement Forge</button>
                    </div>
                </div>
            </div> </div> <div v-if="currentPhase === 3">
             <h2 class="phase-title">Phase 3: Arrangement Forge (Work in Progress)</h2>
              <div class="card step-card">
                  <div class="card-body">
                       <p>Build the song section by section according to the map.</p>
                       <button class="btn btn-secondary" @click="goBackToPhase2Lengths">Back (Debug)</button>
                  </div>
              </div>
        </div> </div> <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>

    <script>
        const { createApp, ref, reactive, computed } = Vue;

        createApp({
            // --- DATA ---
            data() {
                return {
                    // --- Core State (from your working version) ---
                    currentPhase: 1,
                    currentStep: 1.1,
                    framework: reactive({ key: null, scale: null, tempo: null }),
                    contextGenerated: false,
                    contextConfirmed: false,
                    // --- Phase 1 State (from your working version) ---
                    currentLayerIndex: 0,
                    layers: reactive([]),
                    structure: reactive({
                        // template: [], // Removed this, using templateName and templateSequence now
                        templateName: null,      // ADDED for Phase 2
                        templateSequence: [],    // ADDED for Phase 2
                        progressions: { A: null },
                        lengths: {},
                        // Phase 2 Status Flags ADDED
                        templateGenerated: false,
                        templateConfirmed: false,
                        lengthsGenerated: false,
                        lengthsConfirmed: false,
                    }),
                    // Phase 2 Specific State ADDED
                    sectionsToDefineHarmony: [], // e.g., ['B', 'Intro', 'Outro']
                    currentSectionIndexToDefine: -1,
                    harmonyConfirmed: reactive({}), // Map: { B: true, C: true }

                    // --- Data Lists (Combined from your version and Phase 2 needs) ---
                    musicalKeys: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
                    musicalScales: [
                        { name: 'Major', type: 'major', definition: 'Standard happy/bright scale' }, { name: 'Natural Minor', type: 'minor', definition: 'Standard sad/dark scale' },
                        { name: 'Harmonic Minor', type: 'minor', definition: 'Minor scale, raised 7th, exotic' }, { name: 'Melodic Minor', type: 'minor', definition: 'Minor scale, raised 6th/7th ascending' },
                        { name: 'Dorian', type: 'minor', definition: 'Minor-like, jazzy/melancholic' }, { name: 'Phrygian', type: 'minor', definition: 'Minor-like, Spanish/dark' },
                        { name: 'Lydian', type: 'major', definition: 'Major-like, dreamy/ethereal' }, { name: 'Mixolydian', type: 'major', definition: 'Major-like, bluesy/dominant' },
                        { name: 'Pentatonic Major', type: 'major', definition: 'Simple 5-note major' }, { name: 'Pentatonic Minor', type: 'minor', definition: 'Simple 5-note minor' },
                        { name: 'Blues Scale', type: 'minor', definition: 'Pentatonic minor + flat 5th' }
                    ],
                    instrumentTypes: ['Foundation Rhythm', 'Groove Bass', 'Main Chords', 'Arpeggio/Sequence', 'Percussive Texture High', 'Simple Lead/Hook', 'Atmospheric Pad/Drone', 'Rhythmic FX/Stab', 'Counter Melody', 'Tuned Percussion'],
                    stylisticModifiers: ['Filtered', 'Reverby/Dreamy', 'Wobbly/Detuned', 'Minimal/Dry', 'Warm/Analog', 'Glitchy/Fragmented', 'Compressed/Pumpy', 'Delayed/Spatial', 'Lo-Fi/Gritty', 'Bright/Crispy', 'Dark/Mellow', 'Wide Stereo'],
                    tempoRange: { min: 70, max: 125 },
                    commonProgressions: {
                        major: ['I-V-vi-IV', 'IV-I-V-vi', 'I-IV-V-I', 'vi-IV-I-V', 'I-vi-IV-V', 'ii-V-I', 'I-iii-IV-V', 'I-V-IV-I'],
                        minor: ['i-VI-III-VII', 'i-iv-v-i', 'i-VII-VI-V', 'vi-iv-i-v', 'i-iv-III-VI', 'ii°-V-i', 'i-VI-iv-v', 'i-v-VI-VII']
                    },
                    // ADDED Phase 2 Data List
                    structureTemplates: [
                        { name: 'Simple A/B Repeat', sequence: ['A', 'B', 'A', 'B'] }, { name: 'Compact Intro/Outro', sequence: ['Intro', 'A', 'B', 'Outro'] },
                        { name: 'Classic Structure', sequence: ['Intro', 'A', 'B', 'A', 'B', 'Outro'] }, { name: 'Verse Emphasis', sequence: ['Intro', 'A', 'A', 'B', 'Outro'] },
                        { name: 'Bridge Structure', sequence: ['Intro', 'A', 'B', 'C', 'B', 'Outro'] }, { name: 'Pre-Chorus Feel', sequence: ['Intro', 'A', 'C', 'B', 'A', 'C', 'B', 'Outro'] },
                        { name: 'Extended A/B', sequence: ['Intro', 'A', 'B', 'A', 'B', 'C', 'B', 'Outro'] }, { name: 'Instrumental Break', sequence: ['Intro', 'A', 'B', 'Instrumental', 'B', 'Outro'] },
                        { name: 'Minimal Loop', sequence: ['A', 'A', 'B', 'A'] }, { name: 'Developing Loop', sequence: ['Intro', 'A', 'A+', 'B', 'B+'] }
                    ],
                     // ADDED Phase 3 Placeholder Data (will be used next)
                     currentArrangementIndex: -1,
                     arrangementLog: reactive({}),
                }
            },
            // --- COMPUTED ---
            computed: {
                 confirmedLayers() { return this.layers.filter(layer => layer.confirmed); },
                 // ADDED Phase 2 Computed Property
                 currentSectionLetterToDefine() {
                      if (this.currentStep !== 2.2 || this.currentSectionIndexToDefine < 0 || this.currentSectionIndexToDefine >= this.sectionsToDefineHarmony.length) {
                           return null;
                      }
                      return this.sectionsToDefineHarmony[this.currentSectionIndexToDefine];
                 }
            },
            // --- METHODS ---
            methods: {
                // --- Helpers (from your working version) ---
                getRandomInt(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1)) + min; },
                getRandomElement(arr) { if (!arr || arr.length === 0) return null; const randomIndex = Math.floor(Math.random() * arr.length); return arr[randomIndex]; },
                getScaleDefinition(scaleName) { const scaleObj = this.musicalScales.find(s => s.name === scaleName); return scaleObj ? scaleObj.definition : 'Unknown scale'; },
                getScaleType(scaleName) { const scaleObj = this.musicalScales.find(s => s.name === scaleName); return scaleObj ? scaleObj.type : 'major'; },
                getConfirmedLayers() { return this.layers.filter(layer => layer.confirmed); },

                // --- Phase 1 Methods (from your working version) ---
                generateContext() { console.log("Generating context..."); const selectedScaleObject = this.getRandomElement(this.musicalScales); this.framework.key = this.getRandomElement(this.musicalKeys); this.framework.scale = selectedScaleObject ? selectedScaleObject.name : null; this.framework.tempo = this.getRandomInt(this.tempoRange.min, this.tempoRange.max); this.contextGenerated = true; this.contextConfirmed = false; this.currentLayerIndex = 0; this.layers.length = 0; this.resetPhase2State(); }, // Added resetPhase2State call
                confirmContext() { console.log("Context confirmed:", this.framework); this.contextConfirmed = true; },
                startLayerGeneration() { if (!this.contextConfirmed) return; console.log("Starting layer generation..."); this.currentStep = 1.2; this.currentLayerIndex = 1; this.initializeLayerData(4); },
                initializeLayerData(count) { this.layers.length = 0; for (let i = 1; i <= count; i++) { this.layers.push(reactive({ id: i, type: null, modifier: null, suggested: false, confirmed: false })); } console.log("Initialized layers:", this.layers); },
                generateLayerSuggestion(layerIndex) { if (layerIndex < 1 || layerIndex > 4) return; console.log(`Generating suggestion for Layer ${layerIndex}`); const layer = this.layers[layerIndex - 1]; if (!layer) return; layer.type = this.getRandomElement(this.instrumentTypes); layer.modifier = this.getRandomElement(this.stylisticModifiers); layer.suggested = true; layer.confirmed = false; console.log(`Suggestion: ${layer.modifier} ${layer.type}`); },
                confirmLayerCreated(layerIndex) { if (layerIndex < 1 || layerIndex > 4) return; console.log(`Confirming Layer ${layerIndex} created.`); const layer = this.layers[layerIndex - 1]; if (!layer || !layer.suggested) return; layer.confirmed = true; if (layerIndex === 4) { console.log("All 4 layers confirmed!"); this.generateInitialProgressionA(); this.currentStep = '1.post'; } else { this.currentLayerIndex++; } },
                generateInitialProgressionA() { console.log("Generating Progression A..."); const scaleType = this.getScaleType(this.framework.scale); let pattern = 'I-IV-V-I'; if (scaleType === 'minor') { pattern = this.getRandomElement(this.commonProgressions.minor); } else { pattern = this.getRandomElement(this.commonProgressions.major); } this.structure.progressions.A = `${pattern}`; console.log("Progression A generated (placeholder):", this.structure.progressions.A); }, // Simplified output as before

                // --- Phase 2 Methods (NEWLY ADDED) ---
                resetPhase2State() { // Helper to clear Phase 2 data if context changes
                    this.structure.templateName = null;
                    this.structure.templateSequence.length = 0;
                    this.structure.progressions = { A: this.structure.progressions.A }; // Keep A
                    this.structure.lengths = {};
                    this.structure.templateGenerated = false;
                    this.structure.templateConfirmed = false;
                    this.structure.lengthsGenerated = false;
                    this.structure.lengthsConfirmed = false;
                    this.sectionsToDefineHarmony.length = 0;
                    this.currentSectionIndexToDefine = -1;
                    this.harmonyConfirmed = reactive({});
                },
                startPhase2() { // Navigation from Phase 1
                    if (this.currentStep === '1.post') {
                        this.currentPhase = 2;
                        this.currentStep = 2.1; // Start Phase 2 at Step 2.1
                        console.log("Moving to Phase 2, Step 2.1");
                         this.resetPhase2State(); // Ensure Phase 2 starts clean, but keeps Progression A
                    }
                },
                generateStructureTemplate() {
                    console.log("Generating structure template...");
                    const selectedTemplate = this.getRandomElement(this.structureTemplates);
                    this.structure.templateName = selectedTemplate.name;
                    this.structure.templateSequence = [...selectedTemplate.sequence];
                    this.structure.templateGenerated = true;
                    this.structure.templateConfirmed = false;
                    const uniqueSections = [...new Set(this.structure.templateSequence)];
                    this.sectionsToDefineHarmony = uniqueSections.filter(s => s !== 'A');
                    Object.keys(this.structure.progressions).forEach(key => { if (key !== 'A') delete this.structure.progressions[key]; });
                    this.harmonyConfirmed = reactive({});
                    console.log("Template:", this.structure.templateName, "Sections needed:", this.sectionsToDefineHarmony);
                },
                confirmStructureTemplate() {
                    if (!this.structure.templateGenerated) return;
                    console.log("Structure template confirmed.");
                    this.structure.templateConfirmed = true;
                    this.currentSectionIndexToDefine = this.sectionsToDefineHarmony.length > 0 ? 0 : -1;
                },
                startHarmonyDefinition() { // Navigation within Phase 2
                    if (!this.structure.templateConfirmed) return;
                    if (this.sectionsToDefineHarmony.length === 0) {
                        console.log("No new sections need harmony. Skipping to Lengths.");
                        this.currentStep = 2.3; // Skip step 2.2
                    } else {
                        this.currentStep = 2.2; // Go to step 2.2
                        this.currentSectionIndexToDefine = 0;
                         console.log("Starting harmony definition for:", this.sectionsToDefineHarmony[0]);
                    }
                },
                generateHarmonyForSection(sectionLetter) {
                    if (!sectionLetter) return;
                    console.log(`Generating harmony pattern for Section '${sectionLetter}'...`);
                    const scaleType = this.getScaleType(this.framework.scale);
                    let availablePatterns = (scaleType === 'minor') ? [...this.commonProgressions.minor] : [...this.commonProgressions.major];
                    if (availablePatterns.length > 1 && this.structure.progressions.A && availablePatterns.includes(this.structure.progressions.A)) {
                        availablePatterns = availablePatterns.filter(p => p !== this.structure.progressions.A);
                    }
                    const pattern = this.getRandomElement(availablePatterns);
                    this.structure.progressions[sectionLetter] = pattern; // Store pattern
                    this.harmonyConfirmed[sectionLetter] = false; // Reset confirmation
                    console.log(`Suggested pattern for ${sectionLetter}: ${pattern}`);
                    // Actual chord generation is still a TODO for a future version
                },
                confirmHarmony(sectionLetter) {
                    if (!sectionLetter || !this.structure.progressions[sectionLetter]) return;
                    console.log(`Harmony confirmed for Section '${sectionLetter}'.`);
                    this.harmonyConfirmed[sectionLetter] = true;
                    const nextIndex = this.currentSectionIndexToDefine + 1;
                    if (nextIndex < this.sectionsToDefineHarmony.length) {
                        this.currentSectionIndexToDefine = nextIndex;
                        console.log("Moving to define harmony for:", this.sectionsToDefineHarmony[nextIndex]);
                    } else {
                        console.log("All section harmonies defined.");
                        this.currentSectionIndexToDefine = -1; // Mark completion
                    }
                },
                 startLengthDefinition() { // Navigation within Phase 2
                     // Check if we are done with harmony definition
                     if(this.currentStep === 2.2 && this.currentSectionIndexToDefine === -1) {
                          this.currentStep = 2.3;
                          console.log("Starting Section Length definition.");
                     }
                 },
                 generateSectionLengths() {
                     console.log("Generating section lengths...");
                     const uniqueSectionsInTemplate = [...new Set(this.structure.templateSequence)];
                     const newLengths = {};
                     uniqueSectionsInTemplate.forEach(section => {
                         let length = 8; const roll = this.getRandomInt(1, 6);
                         if (['A', 'B', 'A+', 'B+'].includes(section)) {
                             if (roll <= 2) length = 8; else if (roll <= 4) length = 12; else length = 16;
                         } else {
                             const roll4 = this.getRandomInt(1, 4);
                             if (roll4 === 1) length = 4; else if (roll4 <= 3) length = 8; else length = 12;
                         }
                         newLengths[section] = length;
                     });
                     this.structure.lengths = reactive(newLengths);
                     this.structure.lengthsGenerated = true;
                     this.structure.lengthsConfirmed = false;
                     console.log("Generated lengths:", this.structure.lengths);
                 },
                 confirmSectionLengths() {
                     if (!this.structure.lengthsGenerated) return;
                     console.log("Section lengths confirmed.");
                     this.structure.lengthsConfirmed = true;
                     // Ready to move to Phase 3, waiting for user click
                 },
                 startPhase3() { // Navigation to Phase 3 (Placeholder Action)
                      if (this.currentStep === 2.3 && this.structure.lengthsConfirmed) {
                           this.currentPhase = 3;
                           this.currentStep = 3.1; // First step of Phase 3
                           console.log("Moving to Phase 3, Step 3.1 (Not fully implemented yet)");
                      }
                 },

                // --- Debug/Nav Helpers (from your working version + Phase 2 nav) ---
                goBackToPhase1Post() { this.currentPhase = 1; this.currentStep = '1.post'; },
                 goBackToContext() { this.currentStep = 1.1; this.currentLayerIndex = 0; },
                 goBackToPhase2Lengths() { // ADDED Debug helper
                     this.currentPhase = 2;
                     this.currentStep = 2.3;
                 }
            },
            // --- MOUNTED ---
            mounted() {
                console.log("Vue App Mounted!");
            }
        }).mount('#app');
    </script>

</body>
</html>