<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Songwriting Game V2.2 (No Build)</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <style>
        /* Stili Base ... Identici ... */
        body { background-color: #f8f9fa; font-family: sans-serif; }
        .phase-title { margin-bottom: 1.5rem; color: #6c757d; border-bottom: 1px solid #dee2e6; padding-bottom: 0.5rem;}
        .step-card { margin-bottom: 1.5rem; }
        .list-group-item span, .layer-suggestion-value, .structure-display span,
        .progression-display span, .length-display span, .arrangement-value span,
        .check-suggestion span, .break-duration span, .summary-value span { font-weight: bold; color: #fd5f00; }
        .layer-suggestion-block { background-color: #e9ecef; border-radius: 0.25rem; padding: 1rem; margin-bottom: 1rem; border-left: 5px solid #fd5f00;}
        .layer-suggestion-label { font-weight: bold; color: #495057; display: block; margin-bottom: 0.2rem;}
        .layer-suggestion-detail { margin-bottom: 0.5rem; }
        .layer-flexibility-note { font-size: 0.85em; font-style: italic; color: #6c757d; margin-top: 0.5rem; }
        .previous-layers { margin-top: 1.5rem; font-size: 0.9rem; }
        .previous-layers .card { margin-bottom: 0.5rem; background-color: #f8f9fa;}
        .previous-layers .card-body { padding: 0.75rem; }
        .previous-layers .card-title { font-size: 1em; margin-bottom: 0.25rem;}
        .previous-layers .badge { margin-right: 5px; font-size: 0.8em;}
        .btn { margin-top: 0.5rem; }
        .chord-sequence span {
            display: inline-block; padding: 0.3em 0.6em; margin: 2px; border-radius: 0.25rem;
            background-color: #dee2e6; color: #212529; font-family: monospace; font-size: 1.1em; border: 1px solid #adb5bd;
        }
        .progression-name { font-size: 0.9em; color: #6c757d; margin-bottom: 0.5rem; display: block; }
        /* Nuovo stile per note accordo */
        .chord-notes { font-size: 0.8em; color: #495057; font-family: monospace; }

    </style>
</head>
<body>
    <div id="app" class="container mt-4 mb-5">
        <h1 class="mb-3">The Songwriting Game V2.2</h1>
        <hr>

        <div v-if="currentPhase === 1">
             <h2 class="phase-title">Fase 1: Definizione Nucleo Sonoro</h2>
             <div class="card step-card" v-if="currentStep === 1.1">
                 <div class="card-body">
                     <h5 class="card-title">Step 1.1: Contesto & Progressione Base</h5>
                     <div v-if="!contextGenerated && !contextConfirmed">
                         <p>Definiamo le fondamenta musicali...</p>
                         <button class="btn btn-primary" @click="generateContext">Genera Tonalità, Scala & Tempo</button>
                     </div>
                     <div v-if="contextGenerated && !contextConfirmed">
                         <p>Contesto suggerito:</p>
                         <ul class="list-group mb-3">
                             <li class="list-group-item">Tonalità: <span>{{ framework.key }}</span></li>
                             <li class="list-group-item">Scala/Modo: <span>{{ framework.scale }}</span> <small>({{ getScaleDefinition(framework.scale) }})</small></li>
                             <li class="list-group-item">Tempo: <span>{{ framework.tempo }} BPM</span></li>
                         </ul>
                         <button class="btn btn-success me-2" @click="confirmContext">Conferma Contesto</button>
                         <button class="btn btn-secondary" @click="generateContext" :disabled="progressionAGenerated">Genera di Nuovo</button>
                     </div>
                     <div v-if="contextConfirmed">
                         <p class="alert alert-success mb-3">Contesto confermato: <strong>{{ framework.key }} {{ framework.scale }}</strong> @ <strong>{{ framework.tempo }} BPM</strong>.</p>
                         <div v-if="progressionAGenerated" class="mb-3">
                              <h6>Progressione Armonica Iniziale (Progressione 'A'):</h6>
                              <span v-if="structure.progressions.A_name" class="progression-name">Nome: {{ structure.progressions.A_name }}</span>
                              <div class="progression-display chord-sequence mb-2">
                                 <span v-for="(chord, index) in structure.progressions.A_chords" :key="index">
                                    {{ chord }}
                                    <small v-if="structure.progressions.A_chordNotes && structure.progressions.A_chordNotes[index]" class="d-block chord-notes">({{ structure.progressions.A_chordNotes[index] }})</small>
                                 </span>
                              </div>
                              <small class="d-block mt-1 text-muted">Pattern: {{ structure.progressions.A_pattern }}</small>
                         </div>
                         <button class="btn btn-info" @click="startLayerGeneration" :disabled="!progressionAGenerated">
                             {{ progressionAGenerated ? 'Inizia Creazione Layer 1' : 'Attendi Progressione...' }}
                         </button>
                         <button v-if="progressionAGenerated" class="btn btn-sm btn-outline-secondary ms-2" @click="generateAndDisplayProgressionA">Rigenera Progressione A</button>
                     </div>
                 </div>
             </div>

             <div class="card step-card" v-if="currentStep === 1.2">
                  <div class="card-body">
                      <h5 class="card-title">Step 1.2: Crea Layer Iniziali ({{ currentLayerIndex }} / 4)</h5>
                      <p><strong>Contesto:</strong> {{ framework.key }} {{ framework.scale }}, {{ framework.tempo }} BPM</p>
                       <p><strong>Progressione A:</strong> <span class="chord-sequence"><span v-for="(chord, index) in structure.progressions.A_chords" :key="index">{{ chord }}</span></span></p>
                      <hr>
                      <div v-if="layers[currentLayerIndex - 1]">
                          <div v-if="!layers[currentLayerIndex - 1].suggested">
                              <p>Pronto per il <strong>Layer {{ currentLayerIndex }}</strong>?</p>
                              <button class="btn btn-primary" @click="generateLayerSuggestion(currentLayerIndex)">Genera Suggerimento L{{currentLayerIndex}}</button>
                          </div>
                          <div v-if="layers[currentLayerIndex - 1].suggested && !layers[currentLayerIndex - 1].confirmed">
                              <p>Suggerimento per <strong>Layer {{ currentLayerIndex }}</strong>:</p>
                              <div class="layer-suggestion-block">
                                  <div class="layer-suggestion-detail"> <span class="layer-suggestion-label">Categoria:</span> <span class="layer-suggestion-value">{{ layers[currentLayerIndex - 1].category }}</span> </div>
                                  <div class="layer-suggestion-detail"> <span class="layer-suggestion-label">Suono Specifico:</span> <span class="layer-suggestion-value">{{ layers[currentLayerIndex - 1].specificSound }}</span> </div>
                                  <div class="row">
                                      <div class="col-md-6 layer-suggestion-detail"> <span class="layer-suggestion-label">Ruolo Primario:</span> <span class="layer-suggestion-value">{{ layers[currentLayerIndex - 1].role }}</span> </div>
                                      <div class="col-md-6 layer-suggestion-detail"> <span class="layer-suggestion-label">Range Frequenze Tipico:</span> <span class="layer-suggestion-value">{{ layers[currentLayerIndex - 1].freqRange }}</span> </div>
                                  </div>
                                  <div class="layer-suggestion-detail">
                                       <span class="layer-suggestion-label">Range Note Tipico:</span>
                                       <span class="layer-suggestion-value">{{ layers[currentLayerIndex - 1].typicalNotes || 'N/D' }}</span>
                                  </div>
                                  <div v-if="layers[currentLayerIndex - 1].flexibilityNote" class="layer-flexibility-note"> <i class="bi bi-info-circle"></i> {{ layers[currentLayerIndex - 1].flexibilityNote }} </div>
                              </div>
                              <button class="btn btn-success" @click="confirmLayerCreated(currentLayerIndex)">Confermo Layer {{currentLayerIndex}} Creato</button>
                              <button class="btn btn-secondary ms-2" @click="generateLayerSuggestion(currentLayerIndex)">Rigenera Suggerimento</button>
                          </div>
                      </div>
                      <div class="previous-layers" v-if="getConfirmedLayers.length > 0">
                          <h6>Layer Confermati:</h6>
                          <div class="row">
                              <div class="col-md-6 mb-2" v-for="layer in getConfirmedLayers" :key="layer.id">
                                  <div class="card">
                                      <div class="card-body">
                                          <h6 class="card-title mb-1">L{{ layer.id }}: {{ layer.specificSound }} <span class="badge bg-secondary">{{layer.category}}</span></h6>
                                          <span class="badge bg-info text-dark">{{ layer.role }}</span>
                                          <span class="badge bg-light text-dark">{{ layer.freqRange }}</span>
                                          <span class="badge bg-white text-dark border">{{ layer.typicalNotes || 'N/D' }}</span>
                                      </div>
                                  </div>
                              </div>
                          </div>
                      </div>
                      <div v-if="layers.length === 4 && layers[3].confirmed" class="mt-4">
                            <p class="alert alert-success">Nucleo Sonoro Completo!</p>
                            <button class="btn btn-info" @click="startPhase2">Procedi alla Fase 2: Mappa Struttura</button>
                       </div>
                  </div>
             </div>
        </div>

        <div v-if="currentPhase === 2"> <h2 class="phase-title">Fase 2: Definizione Mappa Struttura</h2> <p class="alert alert-warning">Fase 2 non ancora implementata.</p> <button class="btn btn-secondary" @click="goBackToPhase1Context">Torna a Fase 1</button> </div>
        <div v-if="currentPhase === 3"> <h2 class="phase-title">Fase 3: Forgia Arrangiamento</h2> <p class="alert alert-warning">Fase 3 non ancora implementata.</p> <button class="btn btn-secondary" @click="goBackToPhase1Context">Torna a Fase 1</button> </div>
        <div v-if="currentPhase === 4"> <h2 class="phase-title">Fase 4: Perfezionamento Finale</h2> <p class="alert alert-warning">Fase 4 non ancora implementata.</p> <button class="btn btn-secondary" @click="goBackToPhase1Context">Torna a Fase 1</button> </div>
        <div v-if="currentPhase === 5"> <h2 class="phase-title">Fase 5: Sommario Canzone</h2> <p class="alert alert-warning">Fase 5 non ancora implementata.</p> <button class="btn btn-secondary" @click="goBackToPhase1Context">Torna a Fase 1</button> </div>

    </div>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>

    <script>
        const { createApp, ref, reactive, computed } = Vue;

        // --- Helper Tonal Music Logic ---
        const Tonal = {
             NOTES: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
             getNoteIndex(noteName) { return this.NOTES.indexOf(noteName.toUpperCase()); },
             getNoteFromIndex(index) { return this.NOTES[index % 12]; },
             // Scale Intervals... (Identici a prima)
             SCALE_INTERVALS: { 'major': [0, 2, 4, 5, 7, 9, 11], 'natural minor': [0, 2, 3, 5, 7, 8, 10], 'harmonic minor': [0, 2, 3, 5, 7, 8, 11], 'melodic minor': [0, 2, 3, 5, 7, 9, 11], 'dorian': [0, 2, 3, 5, 7, 9, 10], 'phrygian': [0, 1, 3, 5, 7, 8, 10], 'lydian': [0, 2, 4, 6, 7, 9, 11], 'mixolydian': [0, 2, 4, 5, 7, 9, 10], },
             ROMAN_MAP: { 'I': 1, 'II': 2, 'III': 3, 'IV': 4, 'V': 5, 'VI': 6, 'VII': 7 },

            // NUOVO: Mappa qualità accordo -> intervalli (semitoni da root)
            CHORD_INTERVALS: {
                // Triadi Base
                '': [0, 4, 7], // Maggiore (default)
                'maj': [0, 4, 7],
                'm': [0, 3, 7], // Minore
                'min': [0, 3, 7],
                'dim': [0, 3, 6], // Diminuita
                'aug': [0, 4, 8], // Aumentata
                'sus4': [0, 5, 7],
                'sus2': [0, 2, 7],
                // Settima
                'maj7': [0, 4, 7, 11], // Maggiore Settima
                '7': [0, 4, 7, 10], // Dominante Settima
                'm7': [0, 3, 7, 10], // Minore Settima
                'm(maj7)': [0, 3, 7, 11], // Minore con settima maggiore
                'dim7': [0, 3, 6, 9], // Diminuita Settima (settima diminuita)
                'm7b5': [0, 3, 6, 10], // Semidiminuita (minore settima bemolle quinta)
                 // Sesta
                 '6': [0, 4, 7, 9], // Maggiore Sesta
                 'm6': [0, 3, 7, 9], // Minore Sesta
                  // Nona (base, aggiungono la nona alla settima corrispondente)
                  'maj9': [0, 4, 7, 11, 14], // maj7 + 9
                  '9': [0, 4, 7, 10, 14], // 7 + 9
                  'm9': [0, 3, 7, 10, 14], // m7 + 9
                  '6/9': [0, 4, 7, 9, 14], // 6 + 9
                  // Add more complex chords as needed (e.g., 11, 13, alt, etc.)
             },

             // Funzione traduzione progressione (Identica a prima)
             translateProgression(patternString, key, scaleName) { /* ... Identica a prima V2.1 ... */
                 if (!patternString || !key || !scaleName) return ['Error: Missing info'];
                 const rootIndex = this.getNoteIndex(key); if (rootIndex === -1) return ['Error: Invalid key'];
                 const scaleType = scaleName.toLowerCase().includes('minor') ? 'natural minor' : 'major';
                 const intervals = this.SCALE_INTERVALS[scaleName.toLowerCase().replace(' scale','')] || this.SCALE_INTERVALS[scaleType];
                 if (!intervals) return [`Error: Scale intervals not found for ${scaleName}`];
                 const tokens = patternString.split('-'); const chords = [];
                 for (const token of tokens) {
                     if (!token) continue; const match = token.match(/^(b|#)?(VII|VI|V|IV|III|II|I)(.*)$/i);
                     if (!match) { chords.push(`Err: ${token}`); continue; }
                     const accidental = match[1]; const roman = match[2].toUpperCase(); let quality = match[3] || '';
                     const degree = this.ROMAN_MAP[roman]; if (!degree) { chords.push(`Err: ${token}`); continue; }
                     let intervalIndex = degree - 1; let noteIndex = (rootIndex + intervals[intervalIndex]) % 12;
                     if (accidental === 'b') noteIndex = (noteIndex + 11) % 12; if (accidental === '#') noteIndex = (noteIndex + 1) % 12;
                     const chordRootNote = this.getNoteFromIndex(noteIndex);
                     if (!quality) { quality = (match[2] === roman) ? '' : 'm'; if (quality === '' && degree === 7 && scaleType === 'major') quality = 'dim'; if (quality === 'm' && degree === 2 && scaleType === 'natural minor') quality = 'dim'; }
                     if (quality.toLowerCase() === 'maj') quality = ''; if (quality.toLowerCase() === 'min') quality = 'm'; if (quality.toLowerCase() === 'dominant' || quality.toLowerCase() === 'dom') quality = '7'; if (quality === 'ø7' || quality === 'm7b5') quality = 'm7b5'; if (quality === '°7') quality = 'dim7';
                     chords.push(`${chordRootNote}${quality}`);
                 } return chords;
             },

             // NUOVO: Funzione per ottenere le note di un accordo
             getChordNotes(chordName) {
                if (!chordName || chordName.startsWith('Err')) return '?';
                // Regex per estrarre root (con #/b) e qualità
                const match = chordName.match(/^([A-G](#|b)?)(.*)$/);
                if (!match) return '?';

                const rootNote = match[1];
                let quality = match[3] || ''; // maj7, m7, 7, m, dim, etc.
                // Se la qualità è vuota, è maggiore
                 if(quality === '') quality = 'maj';

                const rootIndex = this.getNoteIndex(rootNote);
                if (rootIndex === -1) return '?';

                // Trova gli intervalli per la qualità (case-insensitive fallback)
                const intervals = this.CHORD_INTERVALS[quality] || this.CHORD_INTERVALS[quality.toLowerCase()];

                 if (!intervals) {
                    console.warn(`Intervals not found for chord quality: ${quality}`);
                    // Fallback: prova a vedere se è solo triade maggiore/minore
                    const basicQuality = quality.startsWith('m') ? 'm' : 'maj';
                    const basicIntervals = this.CHORD_INTERVALS[basicQuality];
                    if(basicIntervals) return basicIntervals.map(interval => this.getNoteFromIndex(rootIndex + interval)).join('-');
                    else return '?'; // Non trovato
                 }


                // Calcola e formatta le note
                const notes = intervals.map(interval => this.getNoteFromIndex(rootIndex + interval));
                return notes.join('-'); // Es: "C-E-G-B"
             }
        };

        // --- Vue App ---
        createApp({
            data() {
                return {
                    // --- State ---
                    currentPhase: 1, currentStep: 1.1,
                    framework: reactive({ key: null, scale: null, tempo: null }),
                    contextGenerated: false, contextConfirmed: false, progressionAGenerated: false,
                    currentLayerIndex: 0, layers: reactive([]), // Oggetti layer avranno anche typicalNotes ora
                    structure: reactive({
                        progressions: {
                            A_pattern: null, A_chords: [], A_name: null,
                            A_chordNotes: [] // NUOVO: Array per le note ['C-E-G', 'G-B-D', ...]
                         },
                    }),
                    // --- Data Lists ---
                    musicalKeys: Tonal.NOTES,
                    musicalScales: [ /*...*/ { name: 'Major', type: 'major', definition: 'Standard happy/bright scale' }, { name: 'Natural Minor', type: 'minor', definition: 'Standard sad/dark scale' }, { name: 'Harmonic Minor', type: 'minor', definition: 'Minor scale, raised 7th, exotic' }, { name: 'Melodic Minor', type: 'minor', definition: 'Minor scale, raised 6th/7th ascending' }, { name: 'Dorian', type: 'minor', definition: 'Minor-like, jazzy/melancholic' }, { name: 'Phrygian', type: 'minor', definition: 'Minor-like, Spanish/dark' }, { name: 'Lydian', type: 'major', definition: 'Major-like, dreamy/ethereal' }, { name: 'Mixolydian', type: 'major', definition: 'Major-like, bluesy/dominant' }, ],
                    tempoRange: { min: 70, max: 160 },
                    instrumentCategories: { /* ... Identico a V2.1 ... */ 'Bass': { role: 'Bass', primaryFreqRange: 'Low (40-200Hz)', typicalNotes: 'C0-C2', specificSounds: ['Sub Bass', 'Sine Bass', 'Square Bass', 'FM Bass', 'Acid Bass', 'Reso Bass', 'Acoustic Bass', 'Synth Bass Pluck'], flexibilityNote: 'Alcuni suoni (Acid, Reso) possono avere armoniche medie importanti.' }, 'Rhythmic': { role: 'Rhythm', primaryFreqRange: 'Variable/Full', typicalNotes: 'N/A', specificSounds: ['Kick Drum', 'Snare Drum', 'Hi-Hat Closed', 'Hi-Hat Open', 'Clap', 'Percussion Loop', 'Glitch Sequence', 'Noise FX Loop', 'Shaker/Tambourine'], flexibilityNote: 'Il focus spettrale dipende totalmente dal suono specifico.' }, 'Piano & Keys': { role: 'Harmony/Melody', primaryFreqRange: 'Versatile Mid (100Hz-4kHz)', typicalNotes: 'C2-C7', specificSounds: ['Acoustic Grand Piano', 'Electric Piano (Rhodes)', 'Electric Piano (Wurli)', 'Organ B3 Style', 'Clavinet', 'Harpsichord', 'Synth Keys Soft'], flexibilityNote: 'Range e ruolo dipendono molto dal voicing e dall\'arrangiamento.' }, 'Pad': { role: 'Harmony/Texture', primaryFreqRange: 'Mid (200Hz-2kHz)', typicalNotes: 'C3-C5', specificSounds: ['Saw Pad', 'String Pad', 'Warm Analog Pad', 'Glassy FM Pad', 'Airy Pad', 'Moving/Evolving Pad', 'Choir Pad'], flexibilityNote: 'Può essere usato in registri diversi o per riempire specifiche aree spettrali.' }, 'Synth Lead': { role: 'Melody', primaryFreqRange: 'Mid/High (500Hz-5kHz)', typicalNotes: 'C4-C6', specificSounds: ['Square Lead', 'Saw Lead', 'Sine Lead', 'FM Lead', 'Plucked Lead', 'Hoover Lead', 'Distorted Lead'], flexibilityNote: 'Assicurati che non si scontri troppo con la voce o altri elementi lead.' }, 'Guitar & Plucked': { role: 'Harmony/Melody/Texture', primaryFreqRange: 'Mid (150Hz-5kHz)', typicalNotes: 'E2-E6', specificSounds: ['Acoustic Guitar Strum', 'Acoustic Guitar Fingerstyle', 'Electric Guitar Clean', 'Electric Guitar Crunch', 'Electric Guitar Distorted', 'Harp', 'Synth Pluck Echoes', 'Pizzicato Strings'], flexibilityNote: 'Molto versatile. Il ruolo dipende dal pattern e dal suono.' }, 'Mallets': { role: 'Melody/Texture', primaryFreqRange: 'Mid/High (300Hz-8kHz)', typicalNotes: 'C4-C7', specificSounds: ['Marimba', 'Vibraphone', 'Xylophone', 'Glockenspiel', 'Steel Drum', 'Synth Mallet'], flexibilityNote: 'Suoni brillanti, utili per arpeggi o melodie secondarie.' }, 'Synth Pluck': { role: 'Melody/Harmony', primaryFreqRange: 'Mid/High (200Hz-6kHz)', typicalNotes: 'C3-C6', specificSounds: ['Short Pluck', 'Reso Pluck', 'Delayed Pluck', 'FM Pluck', 'Karplus-Strong Pluck'], flexibilityNote: 'Ottimi per arpeggi, sequenze ritmiche o accordi staccati.' }, 'Strings': { role: 'Harmony/Melody/Texture', primaryFreqRange: 'Mid/High (100Hz-8kHz)', typicalNotes: 'C2-C7', specificSounds: ['Violin Section', 'Viola Section', 'Cello Section', 'Double Bass Section', 'Full String Ensemble Sustain', 'String Ensemble Staccato', 'Synth Strings'], flexibilityNote: 'Molto potenti per armonia orchestrale o linee melodiche espressive.' }, 'Brass': { role: 'Harmony/Melody/Stabs', primaryFreqRange: 'Mid (200Hz-3kHz)', typicalNotes: 'C3-C6', specificSounds: ['Trumpet Section', 'Trombone Section', 'French Horn Section', 'Full Brass Ensemble Sustain', 'Brass Stabs', 'Synth Brass'], flexibilityNote: 'Suono potente, ottimo per fanfare, melodie o accordi incisivi.' }, 'Winds': { role: 'Melody/Texture', primaryFreqRange: 'Mid/High (200Hz-4kHz)', typicalNotes: 'C3-C7', specificSounds: ['Flute Solo', 'Flute Section', 'Clarinet Solo', 'Oboe Solo', 'Synth Flute', 'Woodwind Ensemble'], flexibilityNote: 'Suoni agili, adatti a melodie o contrappunti.' }, 'Voice': { role: 'Melody/Harmony/Texture', primaryFreqRange: 'Mid (150Hz-3kHz)', typicalNotes: 'C3-C6', specificSounds: ['Choir Aahs', 'Choir Oohs', 'Synth Vox Pad', 'Vocal Chop Sequence', 'Solo Synth Voice'], flexibilityNote: 'Può aggiungere un elemento umano o etereo.' }, 'Evolving': { role: 'Texture/Harmony', primaryFreqRange: 'Variable', typicalNotes: 'N/A', specificSounds: ['Long Drone', 'Moving Ambient Texture', 'Slow Sweeping Pad', 'Granular Cloud', 'Complex Sequence'], flexibilityNote: 'Ideali per creare atmosfera e movimento lento.' }, 'Special Effects': { role: 'FX/Texture', primaryFreqRange: 'Variable/Full', typicalNotes: 'N/A', specificSounds: ['Riser', 'Downlifter', 'Impact', 'White Noise Sweep', 'Vinyl Crackle', 'Ambient FX Loop', 'Sci-Fi Sound'], flexibilityNote: 'Usati per transizioni, enfasi o per aggiungere carattere.' } },
                    musicalRoles: ['Bass', 'Rhythm', 'Harmony', 'Melody', 'Texture', 'FX'],
                    frequencyRanges: ['Low', 'Mid', 'High', 'Full', 'Versatile'],
                    commonProgressions: { /* ... Identico a V2.1 ... */ major: [ { name: 'Pop Standard', pattern: 'Imaj7-V7-vi7-IVmaj7' }, { name: 'Pop Alternative', pattern: 'IVmaj7-Imaj7-V7-vi7' }, { name: 'Simple I-IV-V', pattern: 'I-IV-V7-I' }, { name: 'Jazz Standard Cycle', pattern: 'Imaj7-vi7-ii7-V7' }, { name: '50s Feel', pattern: 'I-vi-IV-V7' }, { name: 'Modal/Lydian Hint', pattern: 'IVmaj7-V7-Imaj7-Imaj7' }, /*{ name: 'Canon-esque', pattern: 'Imaj7-V7/vi-vi7-iii7-IVmaj7-Imaj7/V-ii7-V7' }*/ ], minor: [ { name: 'Standard Minor 1', pattern: 'i7-VImaj7-IIImaj7-VIImaj7' }, { name: 'Standard Minor 2', pattern: 'i7-iv7-v7-i7' }, { name: 'Harmonic Feel', pattern: 'i7-iv7-V7-i7' }, { name: 'Andalusian Cadence', pattern: 'i-VII-VI-V' }, { name: 'Minor Descending', pattern: 'i7-VIImaj7-VImaj7-V7' }, /* { name: 'Jazzy Minor ii-V-i', pattern: 'iiø7-V7alt-i(maj7)' }, */ { name: 'Modal Dorian Feel', pattern: 'i7-IV7-i7-IV7'} ] },
                }
            },
            computed: {
                 getConfirmedLayers() { return this.layers.filter(layer => layer.confirmed); },
            },
            methods: {
                // --- Helpers (Identici) ---
                getRandomInt(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1)) + min; }, getRandomElement(arr) { if (!arr || arr.length === 0) return null; const randomIndex = Math.floor(Math.random() * arr.length); return arr[randomIndex]; }, getScaleDefinition(scaleName) { const scaleObj = this.musicalScales.find(s => s.name === scaleName); return scaleObj ? scaleObj.definition : 'Unknown scale'; }, getScaleType(scaleName) { const scaleObj = this.musicalScales.find(s => s.name === scaleName); return scaleObj ? scaleObj.type : 'major'; },
                // --- Reset ---
                resetPhase1State() { /* ... Identico a V2.1 ... */ console.log("Resetting Phase 1 State"); this.framework = reactive({ key: null, scale: null, tempo: null }); this.contextGenerated = false; this.contextConfirmed = false; this.progressionAGenerated = false; this.currentLayerIndex = 0; this.layers.length = 0; this.structure.progressions.A_pattern = null; this.structure.progressions.A_chords = []; this.structure.progressions.A_name = null; this.structure.progressions.A_chordNotes = []; /* <-- Reset note accordi*/ },
                // ==================== PHASE 1 METHODS (V2.2) ====================
                // --- Context & Progression ---
                generateContext() { /* ... Identico a V2.1 ... */ console.log("Generating context..."); this.resetPhase1State(); const selectedScaleObject = this.getRandomElement(this.musicalScales); this.framework.key = this.getRandomElement(this.musicalKeys); this.framework.scale = selectedScaleObject ? selectedScaleObject.name : 'Major'; this.framework.tempo = this.getRandomInt(this.tempoRange.min, this.tempoRange.max); this.contextGenerated = true; this.contextConfirmed = false; this.progressionAGenerated = false; this.currentPhase = 1; this.currentStep = 1.1; console.log("Context proposed:", this.framework); },
                confirmContext() { /* ... Identico a V2.1 ... */ if (!this.contextGenerated) return; console.log("Context confirmed:", this.framework); this.contextConfirmed = true; this.generateAndDisplayProgressionA(); },
                // Modificato per chiamare getChordNotes
                generateAndDisplayProgressionA() {
                     console.log("Generating and Displaying Initial Progression A...");
                     if (!this.framework.scale || !this.framework.key) { /*...*/ return; }
                     const scaleType = this.getScaleType(this.framework.scale);
                     const possibleProgressions = this.commonProgressions[scaleType] || this.commonProgressions.major;
                     const chosenProgression = this.getRandomElement(possibleProgressions);
                     if (!chosenProgression) { /*...*/ return; }

                     this.structure.progressions.A_pattern = chosenProgression.pattern;
                     this.structure.progressions.A_name = chosenProgression.name;
                     // Traduce pattern in nomi accordi
                     this.structure.progressions.A_chords = Tonal.translateProgression( chosenProgression.pattern, this.framework.key, this.framework.scale );
                     // NUOVO: Ottiene le note per ogni accordo tradotto
                     this.structure.progressions.A_chordNotes = this.structure.progressions.A_chords.map(chord => Tonal.getChordNotes(chord));

                     this.progressionAGenerated = true;
                     console.log(`Progression A: ${chosenProgression.name} (${chosenProgression.pattern}) -> ${this.structure.progressions.A_chords.join(' ')}`);
                     console.log(`Chord Notes: ${this.structure.progressions.A_chordNotes.join(' | ')}`);
                 },
                startLayerGeneration() { /* ... Identico a V2.1 ... */ if (!this.contextConfirmed || !this.progressionAGenerated) return; console.log("Starting layer generation..."); if(this.layers.length === 0) this.initializeLayerData(4); this.currentStep = 1.2; this.currentLayerIndex = 1; console.log("Initialized layers structure:", this.layers); },
                // --- Layers ---
                // Modificato per salvare typicalNotes
                initializeLayerData(count) {
                    this.layers.length = 0;
                    for (let i = 1; i <= count; i++) {
                        this.layers.push(reactive({
                            id: i, category: null, specificSound: null, role: null,
                            freqRange: null, typicalNotes: null, // Aggiunto typicalNotes
                            flexibilityNote: null,
                            suggested: false, confirmed: false
                        }));
                    }
                },
                // Modificato per gestione ritmo e typicalNotes
                generateLayerSuggestion(layerIndex) {
                    if (layerIndex < 1 || layerIndex > this.layers.length) return;
                    console.log(`--- Generating suggestion for Layer ${layerIndex} ---`);
                    const currentLayerData = this.layers[layerIndex - 1]; if (!currentLayerData) return;

                    let suggestedCategory = null; let suggestedSound = null; let categoryData = null;
                    const confirmedLayers = this.getConfirmedLayers;
                    const confirmedRoles = confirmedLayers.map(l => l.role);
                    const confirmedFreqs = confirmedLayers.map(l => l.freqRange);
                    // NUOVO: Flag per ritmo
                    const rhythmLayerConfirmed = confirmedLayers.some(l => l.role && l.role.includes('Rhythm'));
                    console.log("Confirmed Roles:", confirmedRoles, "| Rhythm Confirmed:", rhythmLayerConfirmed);
                    console.log("Confirmed Freqs:", confirmedFreqs);

                    if (layerIndex === 1) { /* ... Logica Layer 1 (identica a V2.1 fix) ... */
                        const startingRolePool = ['Rhythm', 'Rhythm', 'Bass', 'Bass', 'Harmony', 'Harmony', 'Texture', 'Melody']; const targetRole = this.getRandomElement(startingRolePool); console.log(`Layer 1: Target Role selected = ${targetRole}`);
                        const possibleCategories = Object.entries(this.instrumentCategories).filter(([catName, data]) => data.role && data.role.includes(targetRole) && (!data.role.includes('FX') || data.role==='FX/Texture') );
                        console.log(`Layer 1: Found ${possibleCategories.length} possible cats for role ${targetRole}:`, possibleCategories.map(p => p[0]));
                        if (possibleCategories.length > 0) { const [catName, catData] = this.getRandomElement(possibleCategories); suggestedCategory = catName; categoryData = catData; console.log(`Layer 1: Selected Cat = ${suggestedCategory}`); }
                        else { console.error(`Layer 1: FAILED to find cat for role: ${targetRole}`); }
                    } else {
                        // Layer 2-4: Gestione Ritmo + Logica Precedente
                        let forceRhythm = false;
                        if (layerIndex >= 3 && !rhythmLayerConfirmed) { // Da layer 3 in poi, controlla se manca ritmo
                             console.log(`Checking if rhythm needed (Layer ${layerIndex}, confirmed: ${rhythmLayerConfirmed})`);
                             // Se è il layer 4 E manca ancora ritmo, FORZA ritmo
                             if (layerIndex === 4) {
                                 console.log("Layer 4 and rhythm missing - Forcing Rhythm suggestion!");
                                 forceRhythm = true;
                             }
                             // Potremmo anche aumentare la probabilità al layer 3 senza forzare
                         }

                        let neededRoles = this.musicalRoles.filter(r => !confirmedRoles.some(cr => cr && cr.includes(r)) && r !== 'FX');
                         // Se forziamo ritmo, quello è l'unico ruolo necessario
                         if (forceRhythm) {
                             neededRoles = ['Rhythm'];
                         } else {
                             // Altrimenti, logica priorità normale
                             if (!rhythmLayerConfirmed && !neededRoles.includes('Rhythm')) neededRoles.push('Rhythm'); // Aggiungi ritmo se manca ma non forzato
                             if (!confirmedRoles.some(cr => cr && cr.includes('Bass'))) neededRoles.push('Bass');
                             if (!confirmedRoles.some(cr => cr && cr.includes('Harmony'))) neededRoles.push('Harmony');
                             neededRoles = [...new Set(neededRoles)];
                         }

                         let neededFreqs = this.frequencyRanges.filter(f => !confirmedFreqs.includes(f) && f !== 'Versatile' && f !== 'Full');
                         if (!confirmedFreqs.some(f => f.includes('Low'))) neededFreqs.push('Low');
                         if (!confirmedFreqs.some(f => f.includes('Mid'))) neededFreqs.push('Mid');
                         if (!confirmedFreqs.some(f => f.includes('High'))) neededFreqs.push('High');
                         neededFreqs = [...new Set(neededFreqs)];
                         console.log("Needed Roles:", neededRoles); console.log("Needed Freqs:", neededFreqs);

                        let potentialCategories = Object.entries(this.instrumentCategories).filter(([catName, catData]) => {
                             if (!catData.role) return false;
                             // NUOVO: Se ritmo è già confermato, escludi nuovi ritmi
                             if (rhythmLayerConfirmed && catData.role.includes('Rhythm')) return false;
                             // Escludi duplicati (tranne Rhythmic se non ancora confermato)
                             if (confirmedLayers.some(l => l.category === catName) && (catName !== 'Rhythmic' || rhythmLayerConfirmed)) return false;
                             // Escludi FX puri
                             if (catData.role.includes('FX') && !catData.role.includes('Texture')) return false;

                             // Se stiamo forzando ritmo, accetta solo categorie ritmiche
                             if(forceRhythm) {
                                 return catData.role.includes('Rhythm');
                             }

                             // Altrimenti, logica normale
                             const fillsNeededRole = neededRoles.some(nr => catData.role.includes(nr));
                             const fillsNeededFreq = neededFreqs.some(nf => catData.primaryFreqRange === nf || (nf === 'Mid' && catData.primaryFreqRange.includes(nf)));
                             if (fillsNeededRole) return true;
                             if ((!neededRoles.some(nr => ['Bass','Harmony','Melody'].includes(nr)) || confirmedLayers.length >= 2) && fillsNeededFreq) return true; // Leggermente aggiustato (>=2 invece di >=3)
                             return false;
                         });
                         console.log("Potential Categories (Primary Filter):", potentialCategories.map(p => p[0]));

                         // Fallback
                         if (potentialCategories.length === 0) {
                             console.warn("No specific category found, broadening search...");
                             potentialCategories = Object.entries(this.instrumentCategories).filter(([catName, catData]) => {
                                  if (!catData.role || (catData.role.includes('FX') && !catData.role.includes('Texture'))) return false;
                                  if (rhythmLayerConfirmed && catData.role.includes('Rhythm')) return false;
                                  if (confirmedLayers.some(l => l.category === catName) && (catName !== 'Rhythmic' || rhythmLayerConfirmed)) return false;
                                  // Se stiamo forzando ritmo nel fallback (improbabile), accetta solo ritmo
                                  if (forceRhythm) return catData.role.includes('Rhythm');
                                  return true; // Prendi quasi tutto ciò che non è già stato preso/escluso
                             });
                             console.log("Potential Categories (Fallback Filter):", potentialCategories.map(p => p[0]));
                         }

                         if (potentialCategories.length > 0) {
                             const [catName, catData] = this.getRandomElement(potentialCategories);
                             suggestedCategory = catName;
                             categoryData = catData;
                         }
                    } // Fine else (Layer 2-4)

                    // --- Aggiornamento Layer ---
                    if (suggestedCategory && categoryData) {
                        suggestedSound = this.getRandomElement(categoryData.specificSounds);
                        console.log(`Suggestion L${layerIndex}: ${suggestedCategory} - ${suggestedSound} (Role: ${categoryData.role}, Freq: ${categoryData.primaryFreqRange})`);
                        currentLayerData.category = suggestedCategory; currentLayerData.specificSound = suggestedSound;
                        currentLayerData.role = categoryData.role; currentLayerData.freqRange = categoryData.primaryFreqRange;
                        // NUOVO: Salva typicalNotes
                        currentLayerData.typicalNotes = categoryData.typicalNotes || 'N/A';
                        currentLayerData.flexibilityNote = categoryData.flexibilityNote || null;
                        currentLayerData.suggested = true; currentLayerData.confirmed = false;
                    } else { /* ... Gestione Errore identica ... */
                        console.error("Could not determine a suggestion for Layer", layerIndex);
                        currentLayerData.category = 'Error'; currentLayerData.specificSound = 'Could not generate suggestion'; currentLayerData.role = '-';
                        currentLayerData.freqRange = '-'; currentLayerData.typicalNotes = '?'; currentLayerData.suggested = true; currentLayerData.confirmed = false;
                    }
                }, // Fine generateLayerSuggestion

                confirmLayerCreated(layerIndex) { /* ... Identico a V2.1 ... */ if (layerIndex < 1 || layerIndex > this.layers.length) return; const layer = this.layers[layerIndex - 1]; if (!layer || !layer.suggested) return; if (layer.category === 'Error') { alert("Errore nella generazione del suggerimento. Prova a rigenerare."); return; } console.log(`Confirming Layer ${layerIndex} created: ${layer.specificSound}`); layer.confirmed = true; if (layerIndex < this.layers.length) { this.currentLayerIndex++; console.log("Moving to Layer", this.currentLayerIndex); window.scrollTo(0, 0); } else { console.log("All 4 initial layers confirmed!"); window.scrollTo(0, 0); } },
                // --- Navigazione ---
                startPhase2() { /* ... Identico a V2.1 ... */ if (this.layers.length === 4 && this.layers[3].confirmed) { this.currentPhase = 2; this.currentStep = 2.1; console.log("Moving to Phase 2, Step 2.1"); window.scrollTo(0, 0); } else { console.warn("Cannot start Phase 2 yet. Layers not complete."); } },
                goBackToPhase1Context() { /* ... Identico a V2.1 ... */ this.currentPhase = 1; this.currentStep = 1.1; },
            },
            mounted() { console.log("Vue App Mounted! Ready for Songwriting Game V2.2."); }
        }).mount('#app');
    </script>
</body>
</html>