<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Songwriting Game</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <style>
        /* Combined Styles */
        body { background-color: #f8f9fa; }
        .phase-title { margin-bottom: 1.5rem; color: #6c757d; }
        .step-card { margin-bottom: 1.5rem; }
        .list-group-item span, .layer-suggestion span, .structure-display span,
        .progression-display span, .length-display span, .arrangement-value span { font-weight: bold; color: #fd5f00; }
        .layer-suggestion { font-size: 1.1rem; margin-bottom: 1rem; }
        .previous-layers { margin-top: 1.5rem; font-size: 0.9rem; }
        .previous-layers .badge { margin-right: 5px; }
        .btn { margin-top: 0.5rem; }
        .structure-sequence .badge { font-size: 1rem; margin: 2px; padding: 0.5em 0.7em; }
        .section-roles { font-size: 0.9em; color: #6c757d; }
        .chord-progression { font-family: monospace; font-size: 1.1em; }
        /* Phase 3 Styles */
        .arrangement-step { padding: 1rem; border-left: 3px solid #dee2e6; margin-bottom: 1rem; background-color: #fff; }
        .arrangement-step.active { border-left-color: #fd5f00; }
        .arrangement-step.completed { border-left-color: #198754; opacity: 0.8; }
        .arrangement-step h6 { margin-bottom: 0.75rem; color: #495057; }
        .initial-layers-list li { font-size: 0.9em; }
        .variation-prompt { font-style: italic; }
    </style>
</head>
<body>

    <div id="app" class="container mt-4 mb-5">
        <h1 class="mb-3">The Songwriting Game</h1>
        <hr>

        <div v-if="currentPhase === 1">
            <h2 class="phase-title">Phase 1: Sonic Core Definition</h2>
            <div class="card step-card" v-if="currentStep === 1.1">
                <div class="card-body"> <h5 class="card-title">Step 1.1: Generate Musical Context</h5> <div v-if="!contextGenerated && !contextConfirmed"> <p>Let's define the musical foundation...</p><button class="btn btn-primary" @click="generateContext">Generate Key, Scale & Tempo</button> </div> <div v-if="contextGenerated && !contextConfirmed"> <p>Suggested context:</p> <ul class="list-group mb-3"> <li class="list-group-item">Key: <span>{{ framework.key }}</span></li> <li class="list-group-item">Scale/Mode: <span>{{ framework.scale }}</span> <small>({{ getScaleDefinition(framework.scale) }})</small></li> <li class="list-group-item">Tempo: <span>{{ framework.tempo }} BPM</span></li> </ul> <button class="btn btn-success me-2" @click="confirmContext">Confirm Context</button> <button class="btn btn-secondary" @click="generateContext">Generate Again</button> </div> <div v-if="contextConfirmed"> <p class="alert alert-success">Context confirmed: <strong>{{ framework.key }} {{ framework.scale }}</strong> @ <strong>{{ framework.tempo }} BPM</strong>.</p> <button class="btn btn-info" @click="startLayerGeneration">Start Creating Layer 1</button> </div> </div>
            </div>
            <div class="card step-card" v-if="currentStep === 1.2">
                 <div class="card-body"> <h5 class="card-title">Step 1.2: Create Initial Layers ({{ currentLayerIndex }} / 4)</h5> <p><strong>Context:</strong> {{ framework.key }} {{ framework.scale }}, {{ framework.tempo }} BPM</p> <hr> <div v-if="layers[currentLayerIndex - 1]"> <div v-if="!layers[currentLayerIndex - 1].suggested"> <p>Ready for <strong>Layer {{ currentLayerIndex }}</strong>?</p> <button class="btn btn-primary" @click="generateLayerSuggestion(currentLayerIndex)">Generate Suggestion L{{currentLayerIndex}}</button> </div> <div v-if="layers[currentLayerIndex - 1].suggested && !layers[currentLayerIndex - 1].confirmed"> <p>Suggestion for <strong>Layer {{ currentLayerIndex }}</strong>:</p> <p class="alert alert-info layer-suggestion">Create a <span>{{ layers[currentLayerIndex - 1].modifier }}</span> <span>{{ layers[currentLayerIndex - 1].type }}</span>.</p> <button class="btn btn-success" @click="confirmLayerCreated(currentLayerIndex)">Confirm L{{currentLayerIndex}} Created</button> <button class="btn btn-secondary ms-2" @click="generateLayerSuggestion(currentLayerIndex)">Regenerate</button> </div> </div> <div class="previous-layers" v-if="getConfirmedLayers().length > 0"> <h6>Confirmed Layers:</h6> <p><span v-for="layer in getConfirmedLayers()" :key="layer.id" class="badge bg-secondary text-light">L{{ layer.id }}: {{ layer.modifier }} {{ layer.type }}</span></p> </div> </div>
            </div>
            <div class="card step-card" v-if="currentStep === '1.post'">
                 <div class="card-body"> <h5 class="card-title">Sonic Core Complete!</h5> <p class="alert alert-success">All 4 initial layers created.</p> <p>Suggested initial chord progression (Progression A):</p> <p class="alert alert-info progression-display"><strong>Progression A:</strong> <span class="chord-progression">{{ structure.progressions.A }}</span></p> <button class="btn btn-info" @click="startPhase2">Proceed to Phase 2</button> </div>
            </div>
        </div>

        <div v-if="currentPhase === 2">
            <h2 class="phase-title">Phase 2: Structure Map Definition</h2>
            <div class="card step-card" v-if="currentStep === 2.1">
                 <div class="card-body"> <h5 class="card-title">Step 2.1: Generate Structure Template</h5> <div v-if="!structure.templateGenerated"> <p>Let's choose a structure...</p><button class="btn btn-primary" @click="generateStructureTemplate">Generate Structure</button> </div> <div v-if="structure.templateGenerated && !structure.templateConfirmed"> <p>Suggested Structure:</p> <div class="structure-display mb-3"> <h6>Name: <span>{{ structure.templateName }}</span></h6> <p>Sequence:</p> <p class="structure-sequence"><span v-for="(section, index) in structure.templateSequence" :key="index" class="badge bg-dark">{{ section }}</span></p> <p class="section-roles"><small>Roles: A=Verse, B=Chorus...</small></p> </div> <button class="btn btn-success me-2" @click="confirmStructureTemplate">Confirm</button> <button class="btn btn-secondary" @click="generateStructureTemplate">Regenerate</button> </div> <div v-if="structure.templateConfirmed"> <p class="alert alert-success">Structure confirmed: <strong>{{ structure.templateName }}</strong></p> <button class="btn btn-info" @click="startHarmonyDefinition">{{ sectionsToDefineHarmony.length > 0 ? 'Define Harmony' : 'Define Lengths' }}</button> </div> </div>
            </div>
            <div class="card step-card" v-if="currentStep === 2.2">
                 <div class="card-body"> <h5 class="card-title">Step 2.2: Define Harmony ({{ currentSectionIndexToDefine + 1 }} / {{ sectionsToDefineHarmony.length }})</h5> <div v-if="currentSectionLetterToDefine"> <p>Define harmony for: <strong style="font-size: 1.5em;">'{{ currentSectionLetterToDefine }}'</strong></p> <p>Ref - Prog A: <code class="chord-progression">{{ structure.progressions.A }}</code></p> <div v-if="!structure.progressions[currentSectionLetterToDefine]"> <button class="btn btn-primary" @click="generateHarmonyForSection(currentSectionLetterToDefine)">Generate Suggestion for '{{ currentSectionLetterToDefine }}'</button> </div> <div v-if="structure.progressions[currentSectionLetterToDefine] && !harmonyConfirmed[currentSectionLetterToDefine]"> <p>Suggested pattern for '{{ currentSectionLetterToDefine }}':</p> <p class="alert alert-info progression-display"><strong>Prog {{ currentSectionLetterToDefine }}:</strong> <span class="chord-progression">{{ structure.progressions[currentSectionLetterToDefine] }}</span> <br><small>(Roman numeral placeholder)</small> </p> <button class="btn btn-success me-2" @click="confirmHarmony(currentSectionLetterToDefine)">Confirm Harmony</button> <button class="btn btn-secondary" @click="generateHarmonyForSection(currentSectionLetterToDefine)">Regenerate</button> </div> <div v-if="harmonyConfirmed[currentSectionLetterToDefine]"> </div> </div> <div v-else> <p class="alert alert-success">All harmonies defined!</p> <button class="btn btn-info" @click="startLengthDefinition">Next: Define Lengths</button> </div> </div>
            </div>
            <div class="card step-card" v-if="currentStep === 2.3">
                 <div class="card-body"> <h5 class="card-title">Step 2.3: Define Section Lengths</h5> <div v-if="!structure.lengthsGenerated"> <p>Determine length for sections...</p><button class="btn btn-primary" @click="generateSectionLengths">Generate Lengths</button> </div> <div v-if="structure.lengthsGenerated && !structure.lengthsConfirmed"> <p>Suggested Lengths:</p> <ul class="list-group mb-3"> <li v-for="(length, section) in structure.lengths" :key="section" class="list-group-item length-display"> Section <strong>'{{ section }}'</strong>: <span>{{ length }} bars</span> </li> </ul> <button class="btn btn-success me-2" @click="confirmSectionLengths">Confirm Lengths</button> <button class="btn btn-secondary" @click="generateSectionLengths">Regenerate</button> </div> <div v-if="structure.lengthsConfirmed"> <p class="alert alert-success">Structure Map defined!</p> <button class="btn btn-info" @click="startPhase3">Proceed to Phase 3: Arrangement Forge</button> </div> </div>
            </div>
        </div>

        <div v-if="currentPhase === 3">
            <h2 class="phase-title">Phase 3: Arrangement Forge <button class="btn btn-sm btn-outline-secondary float-end" @click="skipToPhase4Debug">Skip to Phase 4 (Debug)</button></h2>
            <div class="card step-card">
                <div class="card-body">
                    <div v-if="currentArrangementInstance">
                        <h5 class="card-title">Arranging Section {{ currentArrangementIndex + 1 }} / {{ structure.templateSequence.length }}</h5>
                        <h4>
                            {{ currentArrangementInstance.displayName }}
                            <small class="text-muted">({{ currentArrangementInstance.sectionLetter }}, Instance {{ currentArrangementInstance.instanceNumber }})</small>
                        </h4>
                        <p><strong>Length:</strong> {{ currentArrangementInstance.length }} bars | <strong>Progression:</strong> <code class="chord-progression">{{ currentArrangementInstance.progression }}</code></p>
                        <hr>
                         <div>
                            <div class="arrangement-step" :class="{ active: !currentInstanceLogEntry.adaptationConfirmed, completed: currentInstanceLogEntry.adaptationConfirmed }">
                                <h6>Step 3.2: Harmonic Adaptation</h6>
                                <div v-if="!currentInstanceLogEntry.adaptationConfirmed">
                                    <p v-if="currentArrangementInstance.progression === currentArrangementInstance.previousProgression && currentArrangementIndex > 0">Progression is the same as the previous section. Focus on arrangement variations below.</p>
                                    <p v-else>
                                        <span v-if="currentArrangementIndex === 0">Use your initial 4 layers as the basis for this first section.</span>
                                        <span v-else>Progression changed! Adapt your core harmonic/melodic layers to fit: <code class="chord-progression">{{ currentArrangementInstance.progression }}</code></span>
                                        <br><span v-if="layers.length > 0">Focus on layers like:</span>
                                        <ul class="mt-2 initial-layers-list" v-if="layers.length > 0">
                                            <li v-for="layer in layers">{{ layer.modifier }} {{ layer.type }}</li>
                                        </ul>
                                    </p>
                                    <button class="btn btn-success btn-sm" @click="confirmAdaptation">
                                        {{ (currentArrangementInstance.progression === currentArrangementInstance.previousProgression && currentArrangementIndex > 0) ? 'Continue to Variations' : 'Confirm Layers Adapted / Applied' }}
                                    </button>
                                </div>
                                <div v-else><p class="text-success mb-0"><small>Adaptation Confirmed.</small></p></div>
                            </div>
                            <div class="arrangement-step" :class="{ active: currentInstanceLogEntry.adaptationConfirmed && !currentInstanceLogEntry.variationsConfirmed, completed: currentInstanceLogEntry.variationsConfirmed, 'd-none': !currentInstanceLogEntry.adaptationConfirmed }">
                                <h6>Step 3.3: Arrangement Variations</h6>
                                <div v-if="!currentInstanceLogEntry.variationsConfirmed">
                                    <div v-if="!currentInstanceLogEntry.density">
                                        <p>Ready to add unique character?</p>
                                        <button class="btn btn-primary btn-sm" @click="suggestVariations">Suggest Variations</button>
                                    </div>
                                    <div v-else>
                                        <p>Suggestions:</p>
                                        <ul class="list-unstyled">
                                            <li><strong>Density:</strong> <span class="arrangement-value">{{ currentInstanceLogEntry.density }}</span></li>
                                            <li v-for="(prompt, pIdx) in currentInstanceLogEntry.variations" :key="pIdx"><strong>Prompt {{ pIdx + 1 }}:</strong> <span class="variation-prompt">{{ prompt }}</span></li>
                                        </ul>
                                        <button class="btn btn-success btn-sm me-2" @click="confirmVariations">Confirm Variations Implemented</button>
                                        <button class="btn btn-secondary btn-sm" @click="suggestVariations">Regenerate Suggestions</button>
                                    </div>
                                </div>
                                <div v-else><p class="text-success mb-0"><small>Variations Confirmed.</small></p></div>
                            </div>
                            <div class="arrangement-step" :class="{ active: currentInstanceLogEntry.variationsConfirmed && !currentInstanceLogEntry.transitionConfirmed && !isLastSection, completed: currentInstanceLogEntry.transitionConfirmed, 'd-none': !currentInstanceLogEntry.variationsConfirmed || isLastSection }">
                                <h6>Step 3.4: Transition Out</h6>
                                <div v-if="!currentInstanceLogEntry.transitionConfirmed">
                                    <div v-if="!currentInstanceLogEntry.transition">
                                        <p>Suggest transition to next section?</p>
                                        <button class="btn btn-primary btn-sm" @click="suggestTransition">Suggest Transition</button>
                                    </div>
                                    <div v-else>
                                        <p>Suggested Transition: <span class="arrangement-value">{{ currentInstanceLogEntry.transition }}</span></p>
                                        <button class="btn btn-success btn-sm me-2" @click="confirmTransition">Confirm Transition Implemented</button>
                                        <button class="btn btn-secondary btn-sm" @click="suggestTransition">Regenerate Suggestion</button>
                                    </div>
                                </div>
                                <div v-else><p class="text-success mb-0"><small>Transition Confirmed.</small></p></div>
                            </div>
                             <div class="arrangement-step completed" v-if="isLastSection && currentInstanceLogEntry.variationsConfirmed">
                                <h6>Step 3.4: Transition Out</h6> <p class="mb-0"><small>N/A (Last Section)</small></p>
                            </div>
                            <div class="mt-4 text-center">
                                <button class="btn btn-info" @click="completeCurrentInstance" :disabled="!canCompleteInstance">
                                   {{ isLastSection ? 'Complete Final Section & Proceed to Polish' : 'Complete Section & Move to Next' }}
                                </button>
                            </div>
                        </div> </div>
                     <div v-else>
                         <p class="alert alert-warning">Loading arrangement data or Phase 2 not complete...</p>
                         <button class="btn btn-secondary btn-sm" @click="goBackToPhase2Lengths">Go Back to Phase 2</button>
                    </div>
                </div> </div> </div> <div v-if="currentPhase === 4">
            <h2 class="phase-title">Phase 4: Final Polish (Work in Progress)</h2>
            <div class="card step-card">
                <div class="card-body">
                    <p>Structured final review with guided checks.</p>
                    <button class="btn btn-secondary" @click="goBackToPhase3">Back (Debug)</button>
                </div>
            </div>
        </div> </div> <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>

    <script>
        const { createApp, ref, reactive, computed } = Vue;

        createApp({
            // --- DATA ---
            data() {
                return {
                    // Core & Phase 1 & 2 State (from your working version)
                    currentPhase: 1,
                    currentStep: 1.1,
                    framework: reactive({ key: null, scale: null, tempo: null }),
                    contextGenerated: false, contextConfirmed: false,
                    currentLayerIndex: 0, layers: reactive([]),
                    structure: reactive({ templateName: null, templateSequence: [], progressions: { A: null }, lengths: {}, templateGenerated: false, templateConfirmed: false, lengthsGenerated: false, lengthsConfirmed: false, }),
                    sectionsToDefineHarmony: [], currentSectionIndexToDefine: -1, harmonyConfirmed: reactive({}),

                    // ADDED: Phase 3 State
                    currentArrangementIndex: -1, // Index for structure.templateSequence
                    arrangementLog: reactive({}), // Log for arrangement decisions per instance

                    // Data Lists (Combined - ensure all lists from your working base are here)
                    musicalKeys: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
                    musicalScales: [ // Ensure this list is complete as in your P1/P2 version
                        { name: 'Major', type: 'major', definition: 'Standard happy/bright scale' }, { name: 'Natural Minor', type: 'minor', definition: 'Standard sad/dark scale' },
                        { name: 'Harmonic Minor', type: 'minor', definition: 'Minor scale, raised 7th, exotic' }, { name: 'Melodic Minor', type: 'minor', definition: 'Minor scale, raised 6th/7th ascending' },
                        { name: 'Dorian', type: 'minor', definition: 'Minor-like, jazzy/melancholic' }, { name: 'Phrygian', type: 'minor', definition: 'Minor-like, Spanish/dark' },
                        { name: 'Lydian', type: 'major', definition: 'Major-like, dreamy/ethereal' }, { name: 'Mixolydian', type: 'major', definition: 'Major-like, bluesy/dominant' },
                        { name: 'Pentatonic Major', type: 'major', definition: 'Simple 5-note major' }, { name: 'Pentatonic Minor', type: 'minor', definition: 'Simple 5-note minor' },
                        { name: 'Blues Scale', type: 'minor', definition: 'Pentatonic minor + flat 5th' }
                    ],
                    instrumentTypes: ['Foundation Rhythm', 'Groove Bass', 'Main Chords', 'Arpeggio/Sequence', 'Percussive Texture High', 'Simple Lead/Hook', 'Atmospheric Pad/Drone', 'Rhythmic FX/Stab', 'Counter Melody', 'Tuned Percussion'],
                    stylisticModifiers: ['Filtered', 'Reverby/Dreamy', 'Wobbly/Detuned', 'Minimal/Dry', 'Warm/Analog', 'Glitchy/Fragmented', 'Compressed/Pumpy', 'Delayed/Spatial', 'Lo-Fi/Gritty', 'Bright/Crispy', 'Dark/Mellow', 'Wide Stereo'],
                    tempoRange: { min: 70, max: 125 },
                    commonProgressions: { major: ['I-V-vi-IV', 'IV-I-V-vi', 'I-IV-V-I', 'vi-IV-I-V', 'I-vi-IV-V', 'ii-V-I', 'I-iii-IV-V', 'I-V-IV-I'], minor: ['i-VI-III-VII', 'i-iv-v-i', 'i-VII-VI-V', 'vi-iv-i-v', 'i-iv-III-VI', 'iiÂ°-V-i', 'i-VI-iv-v', 'i-v-VI-VII'] },
                    structureTemplates: [ { name: 'Simple A/B Repeat', sequence: ['A', 'B', 'A', 'B'] }, { name: 'Compact Intro/Outro', sequence: ['Intro', 'A', 'B', 'Outro'] }, { name: 'Classic Structure', sequence: ['Intro', 'A', 'B', 'A', 'B', 'Outro'] }, { name: 'Verse Emphasis', sequence: ['Intro', 'A', 'A', 'B', 'Outro'] }, { name: 'Bridge Structure', sequence: ['Intro', 'A', 'B', 'C', 'B', 'Outro'] }, { name: 'Pre-Chorus Feel', sequence: ['Intro', 'A', 'C', 'B', 'A', 'C', 'B', 'Outro'] }, { name: 'Extended A/B', sequence: ['Intro', 'A', 'B', 'A', 'B', 'C', 'B', 'Outro'] }, { name: 'Instrumental Break', sequence: ['Intro', 'A', 'B', 'Instrumental', 'B', 'Outro'] }, { name: 'Minimal Loop', sequence: ['A', 'A', 'B', 'A'] }, { name: 'Developing Loop', sequence: ['Intro', 'A', 'A+', 'B', 'B+'] } ],

                    // ADDED: Phase 3 Data Lists
                    densityOptions: ['Sparse', 'Medium', 'Dense'],
                    variationPromptOptions: [ // Copied from previous attempt, ensure this is desired
                        "Simplify one layer's rhythm.", "Add filter movement.", "Introduce subtle background FX.",
                        "Double main rhythm element briefly.", "Drop out the bass for 2 bars.", "Make chords more staccato.",
                        "Add a simple counter-melody.", "Use panning/volume automation.", "Introduce a delay throw.", "Slightly detune a melodic element."
                    ],
                    transitionTypes: ['Drop Out', 'Filter Sweep Out', 'Rhythmic Fill', 'Sustained Element', 'FX Swell/Riser', 'Abrupt Cut', 'Delayed Echo Out', 'Silence Gap (1 beat)'],
                }
            },
            // --- COMPUTED ---
            computed: {
                // Phase 1 & 2 Computed Properties (from your working version)
                confirmedLayers() { return this.layers.filter(layer => layer.confirmed); },
                currentSectionLetterToDefine() { if (this.currentStep !== 2.2 || this.currentSectionIndexToDefine < 0 || this.currentSectionIndexToDefine >= this.sectionsToDefineHarmony.length) { return null; } return this.sectionsToDefineHarmony[this.currentSectionIndexToDefine]; },

                // ADDED: Phase 3 Computed Properties
                currentArrangementInstance() {
                    if (this.currentPhase !== 3 || this.currentArrangementIndex < 0 || !this.structure.templateSequence || this.currentArrangementIndex >= this.structure.templateSequence.length) { return null; }
                    const index = this.currentArrangementIndex;
                    const sectionLetter = this.structure.templateSequence[index];
                    const instanceNumber = this.calculateInstanceNumber(index, sectionLetter);
                    const progression = this.structure.progressions[sectionLetter] || 'N/A';
                    const length = this.structure.lengths[sectionLetter] || 'N/A';
                    const logKey = this.getInstanceLogKey(index);
                    let previousProgression = null;
                    if (index > 0) { const prevLetter = this.structure.templateSequence[index - 1]; previousProgression = this.structure.progressions[prevLetter] || 'N/A'; }
                    let baseName = 'Section';
                    if (sectionLetter === 'A') baseName = 'Verse'; else if (sectionLetter === 'B') baseName = 'Chorus'; else if (sectionLetter === 'C') baseName = 'Bridge'; else if (sectionLetter === 'Intro') baseName = 'Intro'; else if (sectionLetter === 'Outro') baseName = 'Outro'; else if (sectionLetter === 'Instrumental') baseName = 'Instrumental'; else if (sectionLetter.endsWith('+')) baseName = 'Variation';
                    const displayName = `${baseName} ${instanceNumber}`;
                    return { index, logKey, sectionLetter, instanceNumber, displayName, progression, length, previousProgression };
                },
                currentInstanceLogEntry() {
                     if (!this.currentArrangementInstance) return {};
                     const key = this.currentArrangementInstance.logKey;
                     if (!this.arrangementLog[key]) { this.initializeLogEntry(key); }
                     return this.arrangementLog[key];
                },
                isLastSection() { if (this.currentPhase !== 3 || !this.structure.templateSequence || this.structure.templateSequence.length === 0) return false; return this.currentArrangementIndex === this.structure.templateSequence.length - 1; },
                canCompleteInstance() {
                     if (!this.currentArrangementInstance || !this.currentInstanceLogEntry) return false;
                     const logEntry = this.currentInstanceLogEntry;
                     const transitionNeeded = !this.isLastSection;
                     return logEntry.adaptationConfirmed && logEntry.variationsConfirmed && (logEntry.transitionConfirmed || !transitionNeeded);
                 }
            },
            // --- METHODS ---
            methods: {
                 // Helpers (from your working version)
                getRandomInt(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1)) + min; },
                getRandomElement(arr) { if (!arr || arr.length === 0) return null; const randomIndex = Math.floor(Math.random() * arr.length); return arr[randomIndex]; },
                getScaleDefinition(scaleName) { const scaleObj = this.musicalScales.find(s => s.name === scaleName); return scaleObj ? scaleObj.definition : 'Unknown scale'; },
                getScaleType(scaleName) { const scaleObj = this.musicalScales.find(s => s.name === scaleName); return scaleObj ? scaleObj.type : 'major'; },
                getConfirmedLayers() { return this.layers.filter(layer => layer.confirmed); },

                // Phase 1 Methods (from your working version)
                generateContext() { console.log("Generating context..."); const selectedScaleObject = this.getRandomElement(this.musicalScales); this.framework.key = this.getRandomElement(this.musicalKeys); this.framework.scale = selectedScaleObject ? selectedScaleObject.name : null; this.framework.tempo = this.getRandomInt(this.tempoRange.min, this.tempoRange.max); this.contextGenerated = true; this.contextConfirmed = false; this.currentLayerIndex = 0; this.layers.length = 0; this.resetPhase2State(); this.resetPhase3State(); }, // Added resetPhase3State call
                confirmContext() { console.log("Context confirmed:", this.framework); this.contextConfirmed = true; },
                startLayerGeneration() { if (!this.contextConfirmed) return; console.log("Starting layer generation..."); this.currentStep = 1.2; this.currentLayerIndex = 1; this.initializeLayerData(4); },
                initializeLayerData(count) { this.layers.length = 0; for (let i = 1; i <= count; i++) { this.layers.push(reactive({ id: i, type: null, modifier: null, suggested: false, confirmed: false })); } console.log("Initialized layers:", this.layers); },
                generateLayerSuggestion(layerIndex) { if (layerIndex < 1 || layerIndex > 4) return; console.log(`Generating suggestion for Layer ${layerIndex}`); const layer = this.layers[layerIndex - 1]; if (!layer) return; layer.type = this.getRandomElement(this.instrumentTypes); layer.modifier = this.getRandomElement(this.stylisticModifiers); layer.suggested = true; layer.confirmed = false; console.log(`Suggestion: ${layer.modifier} ${layer.type}`); },
                confirmLayerCreated(layerIndex) { if (layerIndex < 1 || layerIndex > 4) return; console.log(`Confirming Layer ${layerIndex} created.`); const layer = this.layers[layerIndex - 1]; if (!layer || !layer.suggested) return; layer.confirmed = true; if (layerIndex === 4) { console.log("All 4 layers confirmed!"); this.generateInitialProgressionA(); this.currentStep = '1.post'; } else { this.currentLayerIndex++; } },
                generateInitialProgressionA() { console.log("Generating Progression A..."); const scaleType = this.getScaleType(this.framework.scale); let pattern = 'I-IV-V-I'; if (scaleType === 'minor') { pattern = this.getRandomElement(this.commonProgressions.minor); } else { pattern = this.getRandomElement(this.commonProgressions.major); } this.structure.progressions.A = `${pattern}`; console.log("Progression A generated (placeholder):", this.structure.progressions.A); },

                // Phase 2 Methods (from your working version)
                resetPhase2State() { console.log("Resetting Phase 2 State"); this.structure.templateName = null; this.structure.templateSequence.length = 0; this.structure.progressions = { A: this.structure.progressions.A }; this.structure.lengths = {}; this.structure.templateGenerated = false; this.structure.templateConfirmed = false; this.structure.lengthsGenerated = false; this.structure.lengthsConfirmed = false; this.sectionsToDefineHarmony.length = 0; this.currentSectionIndexToDefine = -1; this.harmonyConfirmed = reactive({}); },
                startPhase2() { if (this.currentStep === '1.post') { this.currentPhase = 2; this.currentStep = 2.1; console.log("Moving to Phase 2, Step 2.1"); /* Don't reset here, reset on context change */ } },
                generateStructureTemplate() { console.log("Generating structure template..."); const selectedTemplate = this.getRandomElement(this.structureTemplates); this.structure.templateName = selectedTemplate.name; this.structure.templateSequence = [...selectedTemplate.sequence]; this.structure.templateGenerated = true; this.structure.templateConfirmed = false; const uniqueSections = [...new Set(this.structure.templateSequence)]; this.sectionsToDefineHarmony = uniqueSections.filter(s => s !== 'A'); Object.keys(this.structure.progressions).forEach(key => { if (key !== 'A') delete this.structure.progressions[key]; }); this.harmonyConfirmed = reactive({}); console.log("Template:", this.structure.templateName, "Sections needed:", this.sectionsToDefineHarmony); },
                confirmStructureTemplate() { if (!this.structure.templateGenerated) return; console.log("Structure template confirmed."); this.structure.templateConfirmed = true; this.currentSectionIndexToDefine = this.sectionsToDefineHarmony.length > 0 ? 0 : -1; },
                startHarmonyDefinition() { if (!this.structure.templateConfirmed) return; if (this.sectionsToDefineHarmony.length === 0) { console.log("Skipping Harmony Definition."); this.currentStep = 2.3; } else { this.currentStep = 2.2; this.currentSectionIndexToDefine = 0; console.log("Starting harmony definition for:", this.sectionsToDefineHarmony[0]); } },
                generateHarmonyForSection(sectionLetter) { if (!sectionLetter) return; console.log(`Generating harmony pattern for Section '${sectionLetter}'...`); const scaleType = this.getScaleType(this.framework.scale); let availablePatterns = (scaleType === 'minor') ? [...this.commonProgressions.minor] : [...this.commonProgressions.major]; if (availablePatterns.length > 1 && this.structure.progressions.A && availablePatterns.includes(this.structure.progressions.A)) { availablePatterns = availablePatterns.filter(p => p !== this.structure.progressions.A); } const pattern = this.getRandomElement(availablePatterns); this.structure.progressions[sectionLetter] = pattern; this.harmonyConfirmed[sectionLetter] = false; console.log(`Suggested pattern for ${sectionLetter}: ${pattern}`); },
                confirmHarmony(sectionLetter) { if (!sectionLetter || !this.structure.progressions[sectionLetter]) return; console.log(`Harmony confirmed for Section '${sectionLetter}'.`); this.harmonyConfirmed[sectionLetter] = true; const nextIndex = this.currentSectionIndexToDefine + 1; if (nextIndex < this.sectionsToDefineHarmony.length) { this.currentSectionIndexToDefine = nextIndex; console.log("Moving to define harmony for:", this.sectionsToDefineHarmony[nextIndex]); } else { console.log("All section harmonies defined."); this.currentSectionIndexToDefine = -1; } },
                startLengthDefinition() { if( (this.currentStep === 2.2 && this.currentSectionIndexToDefine === -1) || (this.currentStep === 2.1 && this.sectionsToDefineHarmony.length === 0) ) { this.currentStep = 2.3; console.log("Starting Section Length definition."); } else { console.warn("Cannot start length definition yet."); } },
                generateSectionLengths() { console.log("Generating section lengths..."); const uniqueSectionsInTemplate = [...new Set(this.structure.templateSequence)]; const newLengths = {}; uniqueSectionsInTemplate.forEach(section => { let length = 8; const roll = this.getRandomInt(1, 6); if (['A', 'B', 'A+', 'B+'].includes(section)) { if (roll <= 2) length = 8; else if (roll <= 4) length = 12; else length = 16; } else { const roll4 = this.getRandomInt(1, 4); if (roll4 === 1) length = 4; else if (roll4 <= 3) length = 8; else length = 12; } newLengths[section] = length; }); this.structure.lengths = reactive(newLengths); this.structure.lengthsGenerated = true; this.structure.lengthsConfirmed = false; console.log("Generated lengths:", this.structure.lengths); },
                confirmSectionLengths() { if (!this.structure.lengthsGenerated) return; console.log("Section lengths confirmed."); this.structure.lengthsConfirmed = true; },

                // ADDED/MODIFIED: Phase 3 Methods
                resetPhase3State() {
                      console.log("Resetting Phase 3 State");
                      this.currentArrangementIndex = -1;
                      this.arrangementLog = reactive({});
                 },
                startPhase3() { // Modified from placeholder in your code
                    if (this.currentPhase === 2 && this.structure.lengthsConfirmed) {
                        this.currentPhase = 3;
                        this.currentStep = 3.1; // Use 3.1 to denote start of Phase 3 processing
                        this.currentArrangementIndex = 0; // Start at the first section instance
                        this.initializeLogEntry(this.getInstanceLogKey(0)); // Initialize log for the first instance
                        console.log("Moving to Phase 3, starting arrangement.");
                    } else {
                        console.warn("Cannot start Phase 3: Phase 2 not complete.");
                    }
                },
                getInstanceLogKey(index) {
                     if (index < 0 || !this.structure.templateSequence || index >= this.structure.templateSequence.length) return null;
                     const sectionLetter = this.structure.templateSequence[index];
                     const instanceNumber = this.calculateInstanceNumber(index, sectionLetter);
                     return `${sectionLetter}-${instanceNumber}`;
                 },
                calculateInstanceNumber(targetIndex, sectionLetter) {
                     let count = 0;
                     if (!this.structure.templateSequence) return 0;
                     for (let i = 0; i <= targetIndex; i++) { if (this.structure.templateSequence[i] === sectionLetter) { count++; } }
                     return count;
                 },
                initializeLogEntry(key) {
                      if (key && !this.arrangementLog[key]) {
                           console.log("Initializing log entry for:", key);
                           this.arrangementLog[key] = reactive({ adaptationConfirmed: false, density: null, variations: [], variationsConfirmed: false, transition: null, transitionConfirmed: false });
                      }
                 },
                confirmAdaptation() {
                      if (!this.currentArrangementInstance) return;
                      const key = this.currentArrangementInstance.logKey;
                      if (this.arrangementLog[key]) { this.arrangementLog[key].adaptationConfirmed = true; console.log(`Adaptation confirmed: ${key}`);}
                 },
                suggestVariations() {
                      if (!this.currentArrangementInstance) return;
                      const key = this.currentArrangementInstance.logKey;
                      if (!this.arrangementLog[key]) this.initializeLogEntry(key);
                      console.log(`Suggesting variations for ${key}`);
                      const densityRoll = this.getRandomInt(1, 6);
                      this.arrangementLog[key].density = (densityRoll <= 2) ? 'Sparse' : (densityRoll <= 4 ? 'Medium' : 'Dense');
                      const numPrompts = this.getRandomInt(1, 4) <= 2 ? 1 : 2;
                      const selectedPrompts = []; let availablePrompts = [...this.variationPromptOptions];
                      for (let i = 0; i < numPrompts && availablePrompts.length > 0; i++) { const randomIndex = Math.floor(Math.random() * availablePrompts.length); selectedPrompts.push(availablePrompts.splice(randomIndex, 1)[0]); }
                      this.arrangementLog[key].variations = selectedPrompts;
                      this.arrangementLog[key].variationsConfirmed = false;
                      console.log("Var Suggest:", this.arrangementLog[key].density, this.arrangementLog[key].variations);
                 },
                confirmVariations() {
                      if (!this.currentArrangementInstance || !this.arrangementLog[this.currentArrangementInstance.logKey]?.density) return;
                      const key = this.currentArrangementInstance.logKey;
                       if (this.arrangementLog[key]) { this.arrangementLog[key].variationsConfirmed = true; console.log(`Variations confirmed: ${key}`);}
                 },
                suggestTransition() {
                     if (!this.currentArrangementInstance || this.isLastSection) return;
                     const key = this.currentArrangementInstance.logKey;
                     if (!this.arrangementLog[key]) this.initializeLogEntry(key);
                     console.log(`Suggesting transition for ${key}`);
                     this.arrangementLog[key].transition = this.getRandomElement(this.transitionTypes);
                     this.arrangementLog[key].transitionConfirmed = false;
                     console.log("Trans Suggest:", this.arrangementLog[key].transition);
                 },
                confirmTransition() {
                     if (!this.currentArrangementInstance || !this.arrangementLog[this.currentArrangementInstance.logKey]?.transition) return;
                     const key = this.currentArrangementInstance.logKey;
                     if (this.arrangementLog[key]) { this.arrangementLog[key].transitionConfirmed = true; console.log(`Transition confirmed: ${key}`);}
                 },
                completeCurrentInstance() {
                     if (!this.canCompleteInstance) { console.warn("Cannot complete instance yet."); return; }
                     console.log(`Completing instance ${this.currentArrangementIndex + 1}`);
                     const nextIndex = this.currentArrangementIndex + 1;
                     if (nextIndex < this.structure.templateSequence.length) {
                         this.currentArrangementIndex = nextIndex;
                         this.initializeLogEntry(this.getInstanceLogKey(nextIndex));
                         console.log("Moving to next instance:", this.currentArrangementIndex + 1);
                         window.scrollTo(0, 0);
                     } else {
                         console.log("Arrangement Forge Complete!");
                         this.startPhase4(); // Move to next phase
                     }
                 },
                startPhase4() { // ADDED: Placeholder action for Phase 4 start
                      this.currentPhase = 4;
                      this.currentStep = 4.1; // First step of Phase 4
                      console.log("Moving to Phase 4: Final Polish (Not implemented yet)");
                 },

                // Debug/Nav Helpers (Ensure relevant ones are kept/added)
                skipToPhase3Debug() { // Debug skip - Keep or adapt if needed
                    this.framework = reactive({ key: 'A', scale: 'Major', tempo: 110 }); this.contextConfirmed = true; this.contextGenerated = true;
                    this.layers = reactive([ { id: 1, type: 'Rhythm', modifier: 'Dry', confirmed: true }, { id: 2, type: 'Bass', modifier: 'Warm', confirmed: true }, { id: 3, type: 'Chords', modifier: 'Reverby', confirmed: true }, { id: 4, type: 'Lead', modifier: 'Filtered', confirmed: true }]);
                    this.structure = reactive({ templateName: 'Classic Structure', templateSequence: ['Intro', 'A', 'B', 'A', 'B', 'Outro'], progressions: { A: 'I-V-vi-IV', B: 'vi-IV-I-V', Intro: 'IV-I', Outro: 'I-V' }, lengths: { A: 16, B: 12, Intro: 8, Outro: 8 }, templateGenerated: true, templateConfirmed: true, lengthsGenerated: true, lengthsConfirmed: true });
                    this.resetPhase3State(); // Clear any partial P3 state
                    this.startPhase3(); // Use the proper transition
                },
                goBackToPhase1Post() { this.currentPhase = 1; this.currentStep = '1.post'; },
                goBackToContext() { this.currentStep = 1.1; this.currentLayerIndex = 0; },
                goBackToPhase2Lengths() { this.currentPhase = 2; this.currentStep = 2.3; },
                goBackToPhase3() { // ADDED back nav
                    this.currentPhase = 3; this.currentStep = 3.1;
                    if (this.currentArrangementIndex < 0 && this.structure.templateSequence?.length > 0) { this.currentArrangementIndex = 0; this.initializeLogEntry(this.getInstanceLogKey(0)); }
                    else if (this.currentArrangementIndex < 0) { this.currentPhase = 2; this.currentStep = 2.3; }
                },
                 skipToPhase4Debug() { // ADDED Debug Helper
                     this.skipToPhase3Debug(); // Setup P3 state first
                     if(this.currentPhase === 3 && this.structure.templateSequence?.length > 0) {
                         // Simulate completing all instances
                         this.structure.templateSequence.forEach((_, index) => {
                             const key = this.getInstanceLogKey(index);
                             if (!this.arrangementLog[key]) this.initializeLogEntry(key);
                             this.arrangementLog[key].adaptationConfirmed = true; this.arrangementLog[key].density = 'Medium';
                             this.arrangementLog[key].variations = ['Debug Variation']; this.arrangementLog[key].variationsConfirmed = true;
                             if (index < this.structure.templateSequence.length - 1) { this.arrangementLog[key].transition = 'Abrupt Cut'; this.arrangementLog[key].transitionConfirmed = true; }
                         });
                         this.currentArrangementIndex = this.structure.templateSequence.length - 1; // Conceptually at the end
                         this.startPhase4(); // Trigger transition
                     } else { console.warn("Cannot skip to P4 without P3 setup."); }
                 }
            },
            // --- MOUNTED ---
            mounted() {
                console.log("Vue App Mounted!");
            }
        }).mount('#app');
    </script>

</body>
</html>