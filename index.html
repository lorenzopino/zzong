<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Songwriting Game V2.4 (Phase 2 Implemented)</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <style>
        /* Styles Identical to Previous Version */
        body { background-color: #f8f9fa; font-family: sans-serif; }
        .phase-title { margin-bottom: 1.5rem; color: #6c757d; border-bottom: 1px solid #dee2e6; padding-bottom: 0.5rem;}
        .step-card { margin-bottom: 1.5rem; }
        .list-group-item span, .layer-suggestion-value, .structure-display span,
        .progression-display span, .length-display span, .arrangement-value span,
        .check-suggestion span, .break-duration span, .summary-value span { font-weight: bold; color: #fd5f00; }
        .layer-suggestion-block { background-color: #e9ecef; border-radius: 0.25rem; padding: 1rem; margin-bottom: 1rem; border-left: 5px solid #fd5f00;}
        .layer-suggestion-label { font-weight: bold; color: #495057; display: block; margin-bottom: 0.2rem;}
        .layer-suggestion-detail { margin-bottom: 0.5rem; }
        .layer-flexibility-note { font-size: 0.85em; font-style: italic; color: #6c757d; margin-top: 0.5rem; }
        .previous-layers { margin-top: 1.5rem; font-size: 0.9rem; }
        .previous-layers .card { margin-bottom: 0.5rem; background-color: #f8f9fa;}
        .previous-layers .card-body { padding: 0.75rem; }
        .previous-layers .card-title { font-size: 1em; margin-bottom: 0.25rem;}
        .previous-layers .badge { margin-right: 5px; font-size: 0.8em;}
        .btn { margin-top: 0.5rem; }
        .chord-sequence span {
            display: inline-block; padding: 0.3em 0.6em; margin: 2px; border-radius: 0.25rem;
            background-color: #dee2e6; color: #212529; font-family: monospace; font-size: 1.1em; border: 1px solid #adb5bd;
        }
        .progression-name { font-size: 0.9em; color: #6c757d; margin-bottom: 0.5rem; display: block; }
        .chord-notes { font-size: 0.8em; color: #495057; font-family: monospace; }
        /* Phase 2 Specific */
        .structure-sequence .badge { font-size: 0.9em; margin: 2px; }
        .length-display strong { min-width: 90px; display: inline-block;}
    </style>
</head>

<body>
    <div id="app" class="container mt-4 mb-5">
        <h1 class="mb-3">The Songwriting Game V2.4</h1>
        <hr>

        <div v-if="currentPhase === 1">
             <h2 class="phase-title">Phase 1: Sonic Core Definition</h2>
             <div class="card step-card" v-if="currentStep === 1.1">
                 <div class="card-body">
                     <h5 class="card-title">Step 1.1: Context & Base Progression</h5>
                     <div v-if="!contextGenerated && !contextConfirmed">
                         <p>Let's define the musical foundation...</p>
                         <button class="btn btn-primary" @click="generateContext">Generate Key, Scale & Tempo</button>
                     </div>
                     <div v-if="contextGenerated && !contextConfirmed">
                         <p>Suggested Context:</p>
                         <ul class="list-group mb-3">
                             <li class="list-group-item">Key: <span>{{ framework.key }}</span></li>
                             <li class="list-group-item">Scale/Mode: <span>{{ framework.scale }}</span> <small>({{ getScaleDefinition(framework.scale) }})</small></li>
                             <li class="list-group-item">Tempo: <span>{{ framework.tempo }} BPM</span></li>
                         </ul>
                         <button class="btn btn-success me-2" @click="confirmContext">Confirm Context</button>
                         <button class="btn btn-secondary" @click="generateContext" :disabled="progressionAGenerated">Generate Again</button>
                     </div>
                     <div v-if="contextConfirmed">
                         <p class="alert alert-success mb-3">Context confirmed: <strong>{{ framework.key }} {{ framework.scale }}</strong> @ <strong>{{ framework.tempo }} BPM</strong>.</p>
                         <div v-if="progressionAGenerated && structure.progressions.A" class="mb-3">
                              <h6>Initial Chord Progression (Progression 'A'):</h6>
                              <span v-if="structure.progressions.A.name" class="progression-name">Name: {{ structure.progressions.A.name }}</span>
                              <div class="progression-display chord-sequence mb-2">
                                 <span v-for="(chord, index) in structure.progressions.A.chords" :key="'A'+index">
                                    {{ chord }}
                                    <small v-if="structure.progressions.A.chordNotes && structure.progressions.A.chordNotes[index]" class="d-block chord-notes">({{ structure.progressions.A.chordNotes[index] }})</small>
                                 </span>
                              </div>
                              <small class="d-block mt-1 text-muted">Pattern: {{ structure.progressions.A.pattern }}</small>
                         </div>
                         <button class="btn btn-info" @click="startLayerGeneration" :disabled="!progressionAGenerated">
                             {{ progressionAGenerated ? 'Start Creating Layer 1' : 'Waiting for Progression...' }}
                         </button>
                         <button v-if="progressionAGenerated" class="btn btn-sm btn-outline-secondary ms-2" @click="generateAndDisplayProgressionA">Regenerate Progression A</button>
                     </div>
                 </div>
             </div>

             <div class="card step-card" v-if="currentStep === 1.2">
                  <div class="card-body">
                      <h5 class="card-title">Step 1.2: Create Initial Layers ({{ currentLayerIndex }} / 4)</h5>
                      <p><strong>Context:</strong> {{ framework.key }} {{ framework.scale }}, {{ framework.tempo }} BPM</p>
                       <p v-if="structure.progressions.A"><strong>Progression A:</strong> <span class="chord-sequence"><span v-for="(chord, index) in structure.progressions.A.chords" :key="'Aref'+index">{{ chord }}</span></span></p>
                      <hr>
                      <div v-if="layers[currentLayerIndex - 1]">
                          <div v-if="!layers[currentLayerIndex - 1].suggested">
                              <p>Ready for <strong>Layer {{ currentLayerIndex }}</strong>?</p>
                              <button class="btn btn-primary" @click="generateLayerSuggestion(currentLayerIndex)">Generate Suggestion L{{currentLayerIndex}}</button>
                          </div>
                          <div v-if="layers[currentLayerIndex - 1].suggested && !layers[currentLayerIndex - 1].confirmed">
                              <p>Suggestion for <strong>Layer {{ currentLayerIndex }}</strong>:</p>
                              <div class="layer-suggestion-block">
                                  <div class="layer-suggestion-detail"> <span class="layer-suggestion-label">Category:</span> <span class="layer-suggestion-value">{{ layers[currentLayerIndex - 1].category }}</span> </div>
                                  <div class="layer-suggestion-detail"> <span class="layer-suggestion-label">Specific Sound:</span> <span class="layer-suggestion-value">{{ layers[currentLayerIndex - 1].specificSound }}</span> </div>
                                  <div class="row"> <div class="col-md-6 layer-suggestion-detail"> <span class="layer-suggestion-label">Primary Role:</span> <span class="layer-suggestion-value">{{ layers[currentLayerIndex - 1].role }}</span> </div> <div class="col-md-6 layer-suggestion-detail"> <span class="layer-suggestion-label">Typical Frequency Range:</span> <span class="layer-suggestion-value">{{ layers[currentLayerIndex - 1].freqRange }}</span> </div> </div>
                                  <div class="layer-suggestion-detail"> <span class="layer-suggestion-label">Typical Note Range:</span> <span class="layer-suggestion-value">{{ layers[currentLayerIndex - 1].typicalNotes || 'N/A' }}</span> </div>
                                  <div v-if="layers[currentLayerIndex - 1].flexibilityNote" class="layer-flexibility-note"> <i class="bi bi-info-circle"></i> {{ layers[currentLayerIndex - 1].flexibilityNote }} </div>
                              </div>
                              <button class="btn btn-success" @click="confirmLayerCreated(currentLayerIndex)">Confirm Layer {{currentLayerIndex}} Created</button>
                              <button class="btn btn-secondary ms-2" @click="generateLayerSuggestion(currentLayerIndex)">Regenerate Suggestion</button>
                          </div>
                      </div>
                      <div class="previous-layers" v-if="getConfirmedLayers.length > 0">
                          <h6>Confirmed Layers:</h6>
                          <div class="row">
                              <div class="col-md-6 mb-2" v-for="layer in getConfirmedLayers" :key="layer.id">
                                  <div class="card">
                                      <div class="card-body">
                                          <h6 class="card-title mb-1">L{{ layer.id }}: {{ layer.specificSound }} <span class="badge bg-secondary">{{layer.category}}</span></h6>
                                          <span class="badge bg-info text-dark">{{ layer.role }}</span>
                                          <span class="badge bg-light text-dark">{{ layer.freqRange }}</span>
                                          <span class="badge bg-white text-dark border">{{ layer.typicalNotes || 'N/A' }}</span>
                                      </div>
                                  </div>
                              </div>
                          </div>
                      </div>
                      <div v-if="layers.length === 4 && layers[3].confirmed" class="mt-4">
                            <p class="alert alert-success">Sonic Core Complete!</p>
                            <button class="btn btn-info" @click="startPhase2">Proceed to Phase 2: Structure Map</button>
                       </div>
                  </div>
             </div>
        </div>
        <div v-if="currentPhase === 2">
             <h2 class="phase-title">Phase 2: Structure Map Definition</h2>

             <div class="card step-card" v-if="currentStep === 2.1">
                 <div class="card-body">
                     <h5 class="card-title">Step 2.1: Generate Structure Template</h5>
                     <div v-if="!structureTemplateGenerated">
                         <p>Let's choose a structure for your song...</p>
                         <button class="btn btn-primary" @click="generateStructureTemplate">Generate Structure</button>
                     </div>
                     <div v-if="structureTemplateGenerated && !structureTemplateConfirmed">
                         <p>Suggested Structure:</p>
                         <div class="structure-display mb-3 p-3 bg-light border rounded">
                             <h6>Name: <span>{{ structure.templateName }}</span></h6>
                             <p class="mb-1">Sequence:</p>
                             <p class="structure-sequence">
                                 <span v-for="(section, index) in structure.templateSequence" :key="index" class="badge bg-dark me-1">{{ section }}</span>
                             </p>
                             <small class="text-muted d-block">Common Roles: A=Verse, B=Chorus, C=Bridge/Pre-Chorus/Instrumental, +/- = Variation</small>
                             <small class="mt-2 mb-0 text-muted d-block">Target Duration Aim: {{ targetTotalBars.min }} - {{ targetTotalBars.max }} bars</small>
                         </div>
                         <button class="btn btn-success me-2" @click="confirmStructureTemplate">Confirm Structure</button>
                         <button class="btn btn-secondary" @click="generateStructureTemplate">Regenerate</button>
                     </div>
                     <div v-if="structureTemplateConfirmed">
                         <p class="alert alert-success">Structure confirmed: <strong>{{ structure.templateName }}</strong> ({{ structure.templateSequence.join('-') }})</p>
                         <button class="btn btn-info" @click="confirmStructureTemplate">
                            {{ sectionsToDefineHarmony.length > 0 ? 'Next: Define Harmony' : 'Next: Define Lengths' }}
                         </button>
                     </div>
                 </div>
             </div>

             <div class="card step-card" v-if="currentStep === 2.2">
                  <div class="card-body">
                     <h5 class="card-title">Step 2.2: Define Harmony ({{ currentSectionIndexToDefine + 1 }} / {{ sectionsToDefineHarmony.length }})</h5>

                     <div v-if="currentSectionLetterToDefine">
                         <p>Define harmony for section type: <strong style="font-size: 1.5em;">'{{ currentSectionLetterToDefine }}'</strong></p>
                         <p><small>Reference - Progression 'A':</small><br>
                             <span class="chord-sequence">
                                <span v-if="structure.progressions.A" v-for="(chord, index) in structure.progressions.A.chords" :key="'Aref'+index">
                                    {{ chord }}
                                    <small v-if="structure.progressions.A.chordNotes && structure.progressions.A.chordNotes[index]" class="d-block chord-notes">({{ structure.progressions.A.chordNotes[index] }})</small>
                                </span>
                                <span v-else>N/A</span>
                             </span>
                         </p>
                         <hr>
                         <div v-if="!structure.progressions[currentSectionLetterToDefine]">
                            <p>Ready to generate a progression for section '{{ currentSectionLetterToDefine }}'?</p>
                            <button class="btn btn-primary" @click="generateHarmonyForSection(currentSectionLetterToDefine)">Generate Suggestion for '{{ currentSectionLetterToDefine }}'</button>
                         </div>
                         <div v-if="structure.progressions[currentSectionLetterToDefine] && !harmonyConfirmed[currentSectionLetterToDefine]">
                              <p>Suggested progression for '{{ currentSectionLetterToDefine }}':</p>
                              <div class="progression-display mb-3 p-3 bg-light border rounded">
                                  <span v-if="structure.progressions[currentSectionLetterToDefine].name" class="progression-name">Name: {{ structure.progressions[currentSectionLetterToDefine].name }}</span>
                                  <div class="chord-sequence mb-2">
                                      <span v-for="(chord, index) in structure.progressions[currentSectionLetterToDefine].chords" :key="currentSectionLetterToDefine+index">
                                        {{ chord }}
                                        <small v-if="structure.progressions[currentSectionLetterToDefine].chordNotes && structure.progressions[currentSectionLetterToDefine].chordNotes[index]" class="d-block chord-notes">({{ structure.progressions[currentSectionLetterToDefine].chordNotes[index] }})</small>
                                     </span>
                                  </div>
                                  <small class="d-block mt-1 text-muted">Pattern: {{ structure.progressions[currentSectionLetterToDefine].pattern }}</small>
                              </div>
                               <button class="btn btn-success me-2" @click="confirmHarmony(currentSectionLetterToDefine)">Confirm Harmony</button>
                               <button class="btn btn-secondary" @click="generateHarmonyForSection(currentSectionLetterToDefine)">Regenerate</button>
                           </div>
                           <div v-if="structure.progressions[currentSectionLetterToDefine] && harmonyConfirmed[currentSectionLetterToDefine]">
                               <p class="text-success"><i class="bi bi-check-lg"></i> Harmony for '{{ currentSectionLetterToDefine }}' confirmed.</p>
                               </div>
                     </div>
                     <div v-else>
                        <p class="alert alert-info">All harmonies defined. Proceeding to lengths...</p>
                     </div>
                  </div>
             </div>

             <div class="card step-card" v-if="currentStep === 2.3">
                  <div class="card-body">
                      <h5 class="card-title">Step 2.3: Define Section Lengths</h5>
                       <div v-if="!structureLengthsGenerated">
                          <p>Determine the length (in bars) for each unique section type to fit the target duration...</p>
                          <p class="text-muted"><small>Target for {{ framework.tempo }} BPM: {{ targetTotalBars.min }} - {{ targetTotalBars.max }} total bars.</small></p>
                          <button class="btn btn-primary" @click="generateSectionLengths">Generate Lengths</button>
                       </div>
                       <div v-if="structureLengthsGenerated && !structureLengthsConfirmed">
                           <p>Suggested Lengths (Total: <span>{{ calculatedTotalBars }}</span> bars / ~<span>{{ calculatedTotalDurationFormatted }}</span>):</p>
                           <ul class="list-group mb-3">
                              <li v-for="(length, section) in structure.lengths" :key="section" class="list-group-item length-display d-flex justify-content-between align-items-center">
                                  Section Type <strong>'{{ section }}'</strong>:
                                  <span class="badge bg-primary rounded-pill">{{ length }} bars</span>
                               </li>
                           </ul>
                            <p v-if="calculatedTotalBars < targetTotalBars.min || calculatedTotalBars > targetTotalBars.max" class="text-warning small">
                                <i class="bi bi-exclamation-triangle"></i> Note: Generated total bars ({{ calculatedTotalBars }}) is outside the target range ({{ targetTotalBars.min }}-{{ targetTotalBars.max }}). Regenerate or accept.
                            </p>
                            <button class="btn btn-success me-2" @click="confirmSectionLengths">Confirm Lengths</button>
                            <button class="btn btn-secondary" @click="generateSectionLengths">Regenerate</button>
                       </div>
                       <div v-if="structureLengthsConfirmed">
                            <p class="alert alert-success">Structure Map defined! (Total: {{ calculatedTotalBars }} bars / ~{{ calculatedTotalDurationFormatted }})</p>
                            <button class="btn btn-info" @click="startPhase3">Proceed to Phase 3: Arrangement Forge</button>
                       </div>
                  </div>
             </div>

             <div class="mt-3">
                 <button class="btn btn-sm btn-outline-secondary" @click="goBackToPhase1Context">Back to Phase 1</button>
             </div>

         </div>
         <div v-if="currentPhase === 3">
            <h2 class="phase-title">Phase 3: Arrangement Forge</h2>
            <p class="alert alert-warning">Phase 3 not yet implemented.</p>
            <button class="btn btn-secondary" @click="goBackToPhase2Lengths">Back to Phase 2</button>
        </div>
        <div v-if="currentPhase === 4">
             <h2 class="phase-title">Phase 4: Final Polish</h2>
             <p class="alert alert-warning">Phase 4 not yet implemented.</p>
             <button class="btn btn-secondary" @click="goBackToPhase2Lengths">Back to Phase 2</button>
        </div>
        <div v-if="currentPhase === 5">
              <h2 class="phase-title">Phase 5: Song Summary</h2>
               <p class="alert alert-warning">Phase 5 not yet implemented.</p>
               <button class="btn btn-secondary" @click="goBackToPhase2Lengths">Back to Phase 2</button>
         </div>

    </div>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>

    <script>
        const { createApp, ref, reactive, computed } = Vue;

        // --- Helper Tonal Music Logic ---
        const Tonal = { /* ... Identical to V2.3 ... */
             NOTES: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
             getNoteIndex(noteName) { return this.NOTES.indexOf(noteName.toUpperCase()); },
             getNoteFromIndex(index) { return this.NOTES[index % 12]; },
             SCALE_INTERVALS: { 'major': [0, 2, 4, 5, 7, 9, 11], 'natural minor': [0, 2, 3, 5, 7, 8, 10], 'harmonic minor': [0, 2, 3, 5, 7, 8, 11], 'melodic minor': [0, 2, 3, 5, 7, 9, 11], 'dorian': [0, 2, 3, 5, 7, 9, 10], 'phrygian': [0, 1, 3, 5, 7, 8, 10], 'lydian': [0, 2, 4, 6, 7, 9, 11], 'mixolydian': [0, 2, 4, 5, 7, 9, 10], },
             ROMAN_MAP: { 'I': 1, 'II': 2, 'III': 3, 'IV': 4, 'V': 5, 'VI': 6, 'VII': 7 },
             CHORD_INTERVALS: { '': [0, 4, 7], 'maj': [0, 4, 7], 'm': [0, 3, 7], 'min': [0, 3, 7], 'dim': [0, 3, 6], 'aug': [0, 4, 8], 'sus4': [0, 5, 7], 'sus2': [0, 2, 7], 'maj7': [0, 4, 7, 11], '7': [0, 4, 7, 10], 'm7': [0, 3, 7, 10], 'm(maj7)': [0, 3, 7, 11], 'dim7': [0, 3, 6, 9], 'm7b5': [0, 3, 6, 10], '6': [0, 4, 7, 9], 'm6': [0, 3, 7, 9], 'maj9': [0, 4, 7, 11, 14], '9': [0, 4, 7, 10, 14], 'm9': [0, 3, 7, 10, 14], '6/9': [0, 4, 7, 9, 14], },
             translateProgression(patternString, key, scaleName) { /* ... Identical ... */ if (!patternString || !key || !scaleName) return ['Error: Missing info']; const rootIndex = this.getNoteIndex(key); if (rootIndex === -1) return ['Error: Invalid key']; const scaleType = scaleName.toLowerCase().includes('minor') ? 'natural minor' : 'major'; const intervals = this.SCALE_INTERVALS[scaleName.toLowerCase().replace(' scale','')] || this.SCALE_INTERVALS[scaleType]; if (!intervals) return [`Error: Scale intervals not found for ${scaleName}`]; const tokens = patternString.split('-'); const chords = []; for (const token of tokens) { if (!token) continue; const match = token.match(/^(b|#)?(VII|VI|V|IV|III|II|I)(.*)$/i); if (!match) { chords.push(`Err: ${token}`); continue; } const accidental = match[1]; const roman = match[2].toUpperCase(); let quality = match[3] || ''; const degree = this.ROMAN_MAP[roman]; if (!degree) { chords.push(`Err: ${token}`); continue; } let intervalIndex = degree - 1; if (intervalIndex >= intervals.length) { console.warn(`Degree ${degree} out of bounds for scale ${scaleName}`); chords.push(`Err: Deg ${degree}`); continue; } let noteIndex = (rootIndex + intervals[intervalIndex]) % 12; if (accidental === 'b') noteIndex = (noteIndex + 11) % 12; if (accidental === '#') noteIndex = (noteIndex + 1) % 12; const chordRootNote = this.getNoteFromIndex(noteIndex); if (!quality) { quality = (match[2] === roman) ? '' : 'm'; if (quality === '' && degree === 7 && scaleType === 'major') quality = 'dim'; if (quality === 'm' && degree === 2 && scaleType === 'natural minor') quality = 'dim'; } if (quality.toLowerCase() === 'maj') quality = ''; if (quality.toLowerCase() === 'min') quality = 'm'; if (quality.toLowerCase() === 'dominant' || quality.toLowerCase() === 'dom') quality = '7'; if (quality === 'ø7' || quality === 'm7b5') quality = 'm7b5'; if (quality === '°7') quality = 'dim7'; chords.push(`${chordRootNote}${quality}`); } return chords; },
             getChordNotes(chordName) { /* ... Identical ... */ if (!chordName || chordName.startsWith('Err')) return '?'; const match = chordName.match(/^([A-G](#|b)?)(.*)$/); if (!match) return '?'; const rootNote = match[1]; let quality = match[3] || ''; if(quality === '') quality = 'maj'; const rootIndex = this.getNoteIndex(rootNote); if (rootIndex === -1) return '?'; const intervals = this.CHORD_INTERVALS[quality] || this.CHORD_INTERVALS[quality.toLowerCase()]; if (!intervals) { console.warn(`Intervals not found for chord quality: ${quality}`); const basicQuality = quality.startsWith('m') ? 'm' : 'maj'; const basicIntervals = this.CHORD_INTERVALS[basicQuality]; if(basicIntervals) return basicIntervals.map(interval => this.getNoteFromIndex(rootIndex + interval)).join('-'); else return '?'; } const notes = intervals.map(interval => this.getNoteFromIndex(rootIndex + interval)); return notes.join('-'); }
        };

        // --- Vue App ---
        createApp({
            data() {
                return {
                    // --- Core State ---
                    currentPhase: 1,
                    currentStep: 1.1,
                    framework: reactive({ key: null, scale: null, tempo: null }),
                    contextGenerated: false, contextConfirmed: false, progressionAGenerated: false,
                    rhythmLayerSlot: null,

                    // --- Phase 1 State ---
                    currentLayerIndex: 0,
                    layers: reactive([]),

                    // --- Phase 2 State ---
                     structure: reactive({
                        templateName: null,
                        templateSequence: [],
                        lengths: {},
                        // Store A from Phase 1, others generated here
                        // Use reactive() for progressions object itself to ensure nested properties trigger updates if needed
                        progressions: reactive({ /* A: { name, pattern, chords, chordNotes } */ }),
                    }),
                    structureTemplateGenerated: false, structureTemplateConfirmed: false,
                    sectionsToDefineHarmony: [], currentSectionIndexToDefine: -1,
                    harmonyConfirmed: reactive({}),
                    structureLengthsGenerated: false, structureLengthsConfirmed: false,
                    targetTotalBars: reactive({ min: 0, max: 0 }),

                    // --- Phase 3-5 State (Placeholders) ---
                    // ...

                    // ==================== DATA LISTS ====================
                    // (Identical to V2.3)
                    musicalKeys: Tonal.NOTES,
                    musicalScales: [ { name: 'Major', type: 'major', definition: 'Standard happy/bright scale' }, { name: 'Natural Minor', type: 'minor', definition: 'Standard sad/dark scale' }, { name: 'Harmonic Minor', type: 'minor', definition: 'Minor scale, raised 7th, exotic feel' }, { name: 'Melodic Minor', type: 'minor', definition: 'Minor scale, raised 6th/7th ascending' }, { name: 'Dorian', type: 'minor', definition: 'Minor-like, jazzy/melancholic feel' }, { name: 'Phrygian', type: 'minor', definition: 'Minor-like, Spanish/dark feel' }, { name: 'Lydian', type: 'major', definition: 'Major-like, dreamy/ethereal feel' }, { name: 'Mixolydian', type: 'major', definition: 'Major-like, bluesy/dominant feel' }, ],
                    tempoRange: { min: 70, max: 160 },
                    instrumentCategories: { 'Bass': { role: 'Bass', primaryFreqRange: 'Low (40-200Hz)', typicalNotes: 'C0-C2', specificSounds: ['Sub Bass', 'Sine Bass', 'Square Bass', 'FM Bass', 'Acid Bass', 'Reso Bass', 'Acoustic Bass', 'Synth Bass Pluck'], flexibilityNote: 'Some sounds (Acid, Reso) can have significant mid-range harmonics.' }, 'Rhythmic': { role: 'Rhythm', primaryFreqRange: 'Variable/Full', typicalNotes: 'N/A', specificSounds: ['Acoustic Kit', 'Electronic Kit', 'Hybrid Kit'], flexibilityNote: 'Build a full drum kit based on the suggested type (Acoustic, Electronic, Hybrid).' }, 'Piano & Keys': { role: 'Harmony/Melody', primaryFreqRange: 'Versatile Mid (100Hz-4kHz)', typicalNotes: 'C2-C7', specificSounds: ['Acoustic Grand Piano', 'Electric Piano (Rhodes)', 'Electric Piano (Wurli)', 'Organ B3 Style', 'Clavinet', 'Harpsichord', 'Synth Keys Soft'], flexibilityNote: 'Range and role depend heavily on voicing and arrangement.' }, 'Pad': { role: 'Harmony/Texture', primaryFreqRange: 'Mid (200Hz-2kHz)', typicalNotes: 'C3-C5', specificSounds: ['Saw Pad', 'String Pad', 'Warm Analog Pad', 'Glassy FM Pad', 'Airy Pad', 'Moving/Evolving Pad', 'Choir Pad'], flexibilityNote: 'Can be used in different registers or to fill specific spectral areas.' }, 'Synth Lead': { role: 'Melody', primaryFreqRange: 'Mid/High (500Hz-5kHz)', typicalNotes: 'C4-C6', specificSounds: ['Square Lead', 'Saw Lead', 'Sine Lead', 'FM Lead', 'Plucked Lead', 'Hoover Lead', 'Distorted Lead'], flexibilityNote: 'Ensure it doesn\'t clash too much with vocals or other lead elements.' }, 'Guitar & Plucked': { role: 'Harmony/Melody/Texture', primaryFreqRange: 'Mid (150Hz-5kHz)', typicalNotes: 'E2-E6', specificSounds: ['Acoustic Guitar Strum', 'Acoustic Guitar Fingerstyle', 'Electric Guitar Clean', 'Electric Guitar Crunch', 'Electric Guitar Distorted', 'Harp', 'Synth Pluck Echoes', 'Pizzicato Strings'], flexibilityNote: 'Very versatile. Role depends on the pattern and sound.' }, 'Mallets': { role: 'Melody/Texture', primaryFreqRange: 'Mid/High (300Hz-8kHz)', typicalNotes: 'C4-C7', specificSounds: ['Marimba', 'Vibraphone', 'Xylophone', 'Glockenspiel', 'Steel Drum', 'Synth Mallet'], flexibilityNote: 'Bright sounds, useful for arpeggios or secondary melodies.' }, 'Synth Pluck': { role: 'Melody/Harmony', primaryFreqRange: 'Mid/High (200Hz-6kHz)', typicalNotes: 'C3-C6', specificSounds: ['Short Pluck', 'Reso Pluck', 'Delayed Pluck', 'FM Pluck', 'Karplus-Strong Pluck'], flexibilityNote: 'Great for arpeggios, rhythmic sequences, or staccato chords.' }, 'Strings': { role: 'Harmony/Melody/Texture', primaryFreqRange: 'Mid/High (100Hz-8kHz)', typicalNotes: 'C2-C7', specificSounds: ['Violin Section', 'Viola Section', 'Cello Section', 'Double Bass Section', 'Full String Ensemble Sustain', 'String Ensemble Staccato', 'Synth Strings'], flexibilityNote: 'Very powerful for orchestral harmony or expressive melodic lines.' }, 'Brass': { role: 'Harmony/Melody/Stabs', primaryFreqRange: 'Mid (200Hz-3kHz)', typicalNotes: 'C3-C6', specificSounds: ['Trumpet Section', 'Trombone Section', 'French Horn Section', 'Full Brass Ensemble Sustain', 'Brass Stabs', 'Synth Brass'], flexibilityNote: 'Powerful sound, great for fanfares, melodies, or punchy chords.' }, 'Winds': { role: 'Melody/Texture', primaryFreqRange: 'Mid/High (200Hz-4kHz)', typicalNotes: 'C3-C7', specificSounds: ['Flute Solo', 'Flute Section', 'Clarinet Solo', 'Oboe Solo', 'Synth Flute', 'Woodwind Ensemble'], flexibilityNote: 'Agile sounds, suitable for melodies or counterpoints.' }, 'Voice': { role: 'Melody/Harmony/Texture', primaryFreqRange: 'Mid (150Hz-3kHz)', typicalNotes: 'C3-C6', specificSounds: ['Choir Aahs', 'Choir Oohs', 'Synth Vox Pad', 'Vocal Chop Sequence', 'Solo Synth Voice'], flexibilityNote: 'Can add a human or ethereal element.' }, 'Evolving': { role: 'Texture/Harmony', primaryFreqRange: 'Variable', typicalNotes: 'N/A', specificSounds: ['Long Drone', 'Moving Ambient Texture', 'Slow Sweeping Pad', 'Granular Cloud', 'Complex Sequence'], flexibilityNote: 'Ideal for creating atmosphere and slow movement.' }, 'Special Effects': { role: 'FX/Texture', primaryFreqRange: 'Variable/Full', typicalNotes: 'N/A', specificSounds: ['Riser', 'Downlifter', 'Impact', 'White Noise Sweep', 'Vinyl Crackle', 'Ambient FX Loop', 'Sci-Fi Sound'], flexibilityNote: 'Used for transitions, emphasis, or adding character.' } },
                    musicalRoles: ['Bass', 'Rhythm', 'Harmony', 'Melody', 'Texture', 'FX'],
                    frequencyRanges: ['Low', 'Mid', 'High', 'Full', 'Versatile'],
                    commonProgressions: { major: [ { name: 'Pop Standard', pattern: 'Imaj7-V7-vi7-IVmaj7' }, { name: 'Pop Alternative', pattern: 'IVmaj7-Imaj7-V7-vi7' }, { name: 'Simple I-IV-V', pattern: 'I-IV-V7-I' }, { name: 'Jazz Standard Cycle', pattern: 'Imaj7-vi7-ii7-V7' }, { name: '50s Feel', pattern: 'I-vi-IV-V7' }, { name: 'Modal/Lydian Hint', pattern: 'IVmaj7-V7-Imaj7-Imaj7' }, ], minor: [ { name: 'Standard Minor 1', pattern: 'i7-VImaj7-IIImaj7-VIImaj7' }, { name: 'Standard Minor 2', pattern: 'i7-iv7-v7-i7' }, { name: 'Harmonic Feel', pattern: 'i7-iv7-V7-i7' }, { name: 'Andalusian Cadence', pattern: 'i-VII-VI-V' }, { name: 'Minor Descending', pattern: 'i7-VIImaj7-VImaj7-V7' }, { name: 'Modal Dorian Feel', pattern: 'i7-IV7-i7-IV7'} ] },
                    // NEW Structure Templates
                    structureTemplates: [
                        { name: 'Verse-Chorus', sequence: ['Intro', 'A', 'B', 'A', 'B', 'Outro'] }, { name: 'Verse Emphasis', sequence: ['Intro', 'A', 'A', 'B', 'A', 'Outro'] },
                        { name: 'Simple A/B Repeat', sequence: ['A', 'B', 'A', 'B'] }, { name: 'Bridge Structure', sequence: ['Intro', 'A', 'B', 'C', 'B', 'Outro'] },
                        { name: 'Pre-Chorus Structure', sequence: ['Intro', 'A', 'C', 'B', 'A', 'C', 'B', 'Outro'] }, { name: 'Developing Loop', sequence: ['A', 'A+', 'B', 'B+'] },
                        { name: 'Minimal Loop', sequence: ['A', 'A', 'B', 'A'] }, { name: 'Extended Form', sequence: ['Intro', 'A', 'B', 'A', 'B', 'C', 'B', 'Outro'] },
                        { name: 'Instrumental Break', sequence: ['Intro', 'A', 'B', 'C', 'B', 'Outro'] }, { name: 'Short & Sweet', sequence: ['Intro', 'A', 'B', 'Outro'] },
                    ]

                }
            },
            computed: {
                // Phase 1
                 getConfirmedLayers() { return this.layers.filter(layer => layer.confirmed); },
                 // Phase 2
                 currentSectionLetterToDefine() { if (this.currentStep !== 2.2 || this.currentSectionIndexToDefine < 0 || this.currentSectionIndexToDefine >= this.sectionsToDefineHarmony.length) { return null; } return this.sectionsToDefineHarmony[this.currentSectionIndexToDefine]; },
                 calculatedTotalBars() { if (!this.structure.templateSequence || this.structure.templateSequence.length === 0 || Object.keys(this.structure.lengths).length === 0) { return 0; } return this.structure.templateSequence.reduce((sum, sectionLetter) => { return sum + (this.structure.lengths[sectionLetter] || 0); }, 0); },
                 calculatedTotalDurationSeconds() { if (!this.framework.tempo || this.framework.tempo <= 0 || this.calculatedTotalBars === 0) { return 0; } const secondsPerBar = (60 / this.framework.tempo) * 4; return this.calculatedTotalBars * secondsPerBar; },
                 calculatedTotalDurationFormatted() { const totalSeconds = this.calculatedTotalDurationSeconds; if (totalSeconds <= 0) return "0:00"; const minutes = Math.floor(totalSeconds / 60); const seconds = Math.round(totalSeconds % 60); return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`; },
            },
            methods: {
                // --- Helpers (Identical) ---
                getRandomInt(min, max) { /*...*/ return Math.floor(Math.random() * (max - min + 1)) + min; }, getRandomElement(arr) { /*...*/ if (!arr || arr.length === 0) return null; const randomIndex = Math.floor(Math.random() * arr.length); return arr[randomIndex]; }, getScaleDefinition(scaleName) { /*...*/ const scaleObj = this.musicalScales.find(s => s.name === scaleName); return scaleObj ? scaleObj.definition : 'Unknown scale'; }, getScaleType(scaleName) { /*...*/ const scaleObj = this.musicalScales.find(s => s.name === scaleName); return scaleObj ? scaleObj.type : 'major'; },

                // --- Reset Methods ---
                resetPhase1State() { console.log("Resetting Phase 1 State"); this.framework = reactive({ key: null, scale: null, tempo: null }); this.contextGenerated = false; this.contextConfirmed = false; this.progressionAGenerated = false; this.rhythmLayerSlot = null; this.currentLayerIndex = 0; this.layers.length = 0; if (this.structure?.progressions?.A) { this.structure.progressions.A = null; } console.log("Phase 1 state reset."); },
                resetPhase2State() { console.log("Resetting Phase 2 State"); this.structure.templateName = null; this.structure.templateSequence.length = 0; this.structure.lengths = reactive({}); Object.keys(this.structure.progressions).forEach(key => { if (key !== 'A') { delete this.structure.progressions[key]; } }); this.structureTemplateGenerated = false; this.structureTemplateConfirmed = false; this.sectionsToDefineHarmony.length = 0; this.currentSectionIndexToDefine = -1; this.harmonyConfirmed = reactive({}); this.structureLengthsGenerated = false; this.structureLengthsConfirmed = false; this.targetTotalBars = reactive({ min: 0, max: 0 }); },

                // ==================== PHASE 1 METHODS ====================
                generateContext() { console.log("Generating context..."); this.resetPhase1State(); this.resetPhase2State(); const selectedScaleObject = this.getRandomElement(this.musicalScales); this.framework.key = this.getRandomElement(this.musicalKeys); this.framework.scale = selectedScaleObject ? selectedScaleObject.name : 'Major'; this.framework.tempo = this.getRandomInt(this.tempoRange.min, this.tempoRange.max); this.contextGenerated = true; this.contextConfirmed = false; this.progressionAGenerated = false; this.currentPhase = 1; this.currentStep = 1.1; console.log("Context proposed:", this.framework); },
                confirmContext() { if (!this.contextGenerated) return; console.log("Context confirmed:", this.framework); this.contextConfirmed = true; this.generateAndDisplayProgressionA(); },
                generateAndDisplayProgressionA() { console.log("Generating and Displaying Initial Progression A..."); if (!this.framework.scale || !this.framework.key) { return; } const scaleType = this.getScaleType(this.framework.scale); const possibleProgressions = this.commonProgressions[scaleType] || this.commonProgressions.major; const chosenProgression = this.getRandomElement(possibleProgressions); if (!chosenProgression) { this.structure.progressions.A = reactive({ name: "Error", pattern: "Error", chords: ["Error"], chordNotes: ["?"] }); this.progressionAGenerated = true; return; } this.structure.progressions.A = reactive({ name: chosenProgression.name, pattern: chosenProgression.pattern, chords: Tonal.translateProgression(chosenProgression.pattern, this.framework.key, this.framework.scale), chordNotes: [] }); this.structure.progressions.A.chordNotes = this.structure.progressions.A.chords.map(chord => Tonal.getChordNotes(chord)); this.progressionAGenerated = true; console.log(`Progression A: ${this.structure.progressions.A.name} (${this.structure.progressions.A.pattern}) -> ${this.structure.progressions.A.chords.join(' ')}`); console.log(`Chord Notes A: ${this.structure.progressions.A.chordNotes.join(' | ')}`); },
                startLayerGeneration() { if (!this.contextConfirmed || !this.progressionAGenerated) return; console.log("Starting layer generation..."); if(this.layers.length === 0) this.initializeLayerData(4); this.rhythmLayerSlot = this.getRandomInt(1, 4); console.log(`Rhythm layer slot pre-assigned to: Layer ${this.rhythmLayerSlot}`); this.currentStep = 1.2; this.currentLayerIndex = 1; console.log("Initialized layers structure:", this.layers); },
                initializeLayerData(count) { this.layers.length = 0; for (let i = 1; i <= count; i++) { this.layers.push(reactive({ id: i, category: null, specificSound: null, role: null, freqRange: null, typicalNotes: null, flexibilityNote: null, suggested: false, confirmed: false })); } },
                generateLayerSuggestion(layerIndex) { /* ... Identical to V2.3 (with rhythm slot logic)... */ if (layerIndex < 1 || layerIndex > this.layers.length || !this.rhythmLayerSlot) return; console.log(`--- Generating suggestion for Layer ${layerIndex} ---`); const currentLayerData = this.layers[layerIndex - 1]; if (!currentLayerData) return; let suggestedCategory = null; let suggestedSound = null; let categoryData = null; const isRhythmSlot = (layerIndex === this.rhythmLayerSlot); console.log(`Layer ${layerIndex}, Is Pre-assigned Rhythm Slot: ${isRhythmSlot}`); let potentialCategories = []; if (isRhythmSlot) { potentialCategories = Object.entries(this.instrumentCategories).filter(([catName, data]) => data.role && data.role.includes('Rhythm')); console.log(`Forcing Rhythm. Found ${potentialCategories.length} rhythmic categories.`); if(potentialCategories.length === 0) console.error("Configuration Error: No categories found with role 'Rhythm'!"); } else { const confirmedLayers = this.getConfirmedLayers; const confirmedRoles = confirmedLayers.map(l => l.role); const confirmedFreqs = confirmedLayers.map(l => l.freqRange); let neededRoles = this.musicalRoles.filter(r => !r.includes('Rhythm') && !r.includes('FX') && !confirmedRoles.some(cr => cr && cr.includes(r)) ); if (!confirmedRoles.some(cr => cr && cr.includes('Bass'))) neededRoles.push('Bass'); if (!confirmedRoles.some(cr => cr && cr.includes('Harmony'))) neededRoles.push('Harmony'); neededRoles = [...new Set(neededRoles)]; let neededFreqs = this.frequencyRanges.filter(f => !confirmedFreqs.includes(f) && f !== 'Versatile' && f !== 'Full'); if (!confirmedFreqs.some(f => f.includes('Low'))) neededFreqs.push('Low'); if (!confirmedFreqs.some(f => f.includes('Mid'))) neededFreqs.push('Mid'); if (!confirmedFreqs.some(f => f.includes('High'))) neededFreqs.push('High'); neededFreqs = [...new Set(neededFreqs)]; console.log("Needed Non-Rhythm Roles:", neededRoles); console.log("Needed Freqs:", neededFreqs); potentialCategories = Object.entries(this.instrumentCategories).filter(([catName, catData]) => { if (!catData.role || catData.role.includes('Rhythm')) return false; if (confirmedLayers.some(l => l.category === catName)) return false; if (catData.role.includes('FX') && !catData.role.includes('Texture')) return false; const fillsNeededRole = neededRoles.some(nr => catData.role.includes(nr)); const fillsNeededFreq = neededFreqs.some(nf => catData.primaryFreqRange === nf || (nf === 'Mid' && catData.primaryFreqRange.includes(nf))); if (fillsNeededRole) return true; if ((!neededRoles.some(nr => ['Bass','Harmony','Melody'].includes(nr)) || confirmedLayers.length >= 2) && fillsNeededFreq) return true; return false; }); console.log("Potential Non-Rhythm Categories (Primary Filter):", potentialCategories.map(p => p[0])); if (potentialCategories.length === 0) { console.warn("No specific non-rhythm category found, broadening search..."); potentialCategories = Object.entries(this.instrumentCategories).filter(([catName, catData]) => catData.role && !catData.role.includes('Rhythm') && (!catData.role.includes('FX') || catData.role==='FX/Texture') && !confirmedLayers.some(l => l.category === catName) ); console.log("Potential Non-Rhythm Categories (Fallback Filter):", potentialCategories.map(p => p[0])); } } if (potentialCategories.length > 0) { const [catName, catData] = this.getRandomElement(potentialCategories); suggestedCategory = catName; categoryData = catData; suggestedSound = this.getRandomElement(catData.specificSounds); console.log(`Suggestion L${layerIndex}: ${suggestedCategory} - ${suggestedSound} (Role: ${categoryData.role}, Freq: ${categoryData.primaryFreqRange})`); currentLayerData.category = suggestedCategory; currentLayerData.specificSound = suggestedSound; currentLayerData.role = categoryData.role; currentLayerData.freqRange = categoryData.primaryFreqRange; currentLayerData.typicalNotes = categoryData.typicalNotes || 'N/A'; currentLayerData.flexibilityNote = categoryData.flexibilityNote || null; currentLayerData.suggested = true; currentLayerData.confirmed = false; } else { console.error(`CRITICAL: Could not determine any suggestion for Layer ${layerIndex} (Is Rhythm Slot: ${isRhythmSlot})`); currentLayerData.category = 'Error'; currentLayerData.specificSound = 'Suggestion Logic Failed'; currentLayerData.role = '-'; currentLayerData.freqRange = '-'; currentLayerData.typicalNotes = '?'; currentLayerData.suggested = true; currentLayerData.confirmed = false; } },
                confirmLayerCreated(layerIndex) { /* ... Identical to V2.3 ... */ if (layerIndex < 1 || layerIndex > this.layers.length) return; const layer = this.layers[layerIndex - 1]; if (!layer || !layer.suggested) return; if (layer.category === 'Error') { alert("Suggestion generation failed. Please try regenerating."); return; } console.log(`Confirming Layer ${layerIndex} created: ${layer.specificSound}`); layer.confirmed = true; if (layerIndex < this.layers.length) { this.currentLayerIndex++; console.log("Moving to Layer", this.currentLayerIndex); window.scrollTo(0, 0); } else { console.log("All 4 initial layers confirmed!"); window.scrollTo(0, 0); } },

                // ==================== PHASE 2 METHODS ====================
                startPhase2() { if (this.layers.length === 4 && this.layers[3].confirmed) { this.resetPhase2State(); this.currentPhase = 2; this.currentStep = 2.1; console.log("Moving to Phase 2, Step 2.1"); window.scrollTo(0, 0); } else { console.warn("Cannot start Phase 2 yet. Layers not complete."); } },
                generateStructureTemplate() { console.log("Generating structure template..."); this.resetPhase2State(); const selectedTemplate = this.getRandomElement(this.structureTemplates); this.structure.templateName = selectedTemplate.name; this.structure.templateSequence = [...selectedTemplate.sequence]; this.structureTemplateGenerated = true; this.structureTemplateConfirmed = false; const uniqueSections = [...new Set(this.structure.templateSequence)]; this.sectionsToDefineHarmony = uniqueSections.filter(s => s !== 'A' && !this.structure.progressions[s]); if (this.framework.tempo && this.framework.tempo > 0) { const targetDurationMin = 150; const targetDurationMax = 210; const secondsPerBar = (60 / this.framework.tempo) * 4; this.targetTotalBars.min = Math.round(targetDurationMin / secondsPerBar); this.targetTotalBars.max = Math.round(targetDurationMax / secondsPerBar); console.log(`Target Bar Range calculated: ${this.targetTotalBars.min} - ${this.targetTotalBars.max} bars for ${this.framework.tempo} BPM.`); } else { console.warn("Tempo not available, cannot calculate target bars accurately."); this.targetTotalBars.min = 60; this.targetTotalBars.max = 100; } console.log(`Template: ${this.structure.templateName}, Sequence: ${this.structure.templateSequence.join('-')}`); console.log("Sections needing harmony:", this.sectionsToDefineHarmony); },
                confirmStructureTemplate() { if (!this.structureTemplateGenerated) return; this.structureTemplateConfirmed = true; console.log(`Structure Template Confirmed: ${this.structure.templateName}`); if (this.sectionsToDefineHarmony.length > 0) { this.currentStep = 2.2; this.currentSectionIndexToDefine = 0; console.log("Proceeding to Step 2.2: Define Harmony for", this.currentSectionLetterToDefine); } else { this.currentStep = 2.3; console.log("No extra sections need harmony. Proceeding to Step 2.3: Define Lengths"); } },
                generateHarmonyForSection(sectionLetter) { if (!sectionLetter) return; console.log(`Generating harmony for Section '${sectionLetter}'...`); const scaleType = this.getScaleType(this.framework.scale); let possibleProgressions = [...(this.commonProgressions[scaleType] || this.commonProgressions.major)]; const usedPatterns = Object.values(this.structure.progressions).map(p => p?.pattern).filter(p => p); let availableProgressions = possibleProgressions.filter(p => !usedPatterns.includes(p.pattern)); if (availableProgressions.length === 0) { console.warn(`No unused progressions found for ${sectionLetter}, reusing...`); availableProgressions = possibleProgressions; } const chosenProgression = this.getRandomElement(availableProgressions); if (!chosenProgression) { console.error(`Failed to select any progression for ${sectionLetter}`); return; } this.structure.progressions[sectionLetter] = reactive({ name: chosenProgression.name, pattern: chosenProgression.pattern, chords: Tonal.translateProgression(chosenProgression.pattern, this.framework.key, this.framework.scale), chordNotes: [] }); this.structure.progressions[sectionLetter].chordNotes = this.structure.progressions[sectionLetter].chords.map(chord => Tonal.getChordNotes(chord)); this.harmonyConfirmed[sectionLetter] = false; console.log(`Suggested Progression ${sectionLetter}: ${chosenProgression.name} (${chosenProgression.pattern}) -> ${this.structure.progressions[sectionLetter].chords.join(' ')}`); },
                confirmHarmony(sectionLetter) { if (!sectionLetter || !this.structure.progressions[sectionLetter]) return; console.log(`Harmony confirmed for Section '${sectionLetter}'.`); this.harmonyConfirmed[sectionLetter] = true; const nextIndex = this.currentSectionIndexToDefine + 1; if (nextIndex < this.sectionsToDefineHarmony.length) { this.currentSectionIndexToDefine = nextIndex; console.log("Moving to define harmony for:", this.currentSectionLetterToDefine); } else { console.log("All section harmonies defined."); this.currentStep = 2.3; this.currentSectionIndexToDefine = -1; } },
                generateSectionLengths() { console.log("Generating section lengths (target bars: " + this.targetTotalBars.min + "-" + this.targetTotalBars.max + ")"); if (!this.structure.templateSequence || this.structure.templateSequence.length === 0) { console.error("Cannot generate lengths without a structure sequence."); return; } const uniqueSections = [...new Set(this.structure.templateSequence)]; const sectionCounts = this.structure.templateSequence.reduce((counts, section) => { counts[section] = (counts[section] || 0) + 1; return counts; }, {}); const newLengths = {}; const MAX_ITERATIONS = 50; let iterations = 0; let currentTotalBars = 0; uniqueSections.forEach(section => { let length = 8; if (['A', 'B', 'C'].includes(section) || section.endsWith('+')) { length = this.getRandomElement([8, 12, 16]); } else { length = this.getRandomElement([4, 8, 12]); } newLengths[section] = length; }); do { currentTotalBars = this.structure.templateSequence.reduce((sum, section) => sum + (newLengths[section] || 0), 0); if (currentTotalBars >= this.targetTotalBars.min && currentTotalBars <= this.targetTotalBars.max) { console.log(`Target duration met after ${iterations} adjustments. Total bars: ${currentTotalBars}`); break; } if (iterations >= MAX_ITERATIONS) { console.warn(`Max adjustment iterations (${MAX_ITERATIONS}) reached. Final bars: ${currentTotalBars}`); break; } let sectionToAdjust = 'A'; if (!newLengths['A'] || (newLengths['B'] && (sectionCounts['B'] || 0) >= (sectionCounts['A'] || 0))) { sectionToAdjust = 'B'; } if (!newLengths[sectionToAdjust] || (sectionCounts[sectionToAdjust] || 0) < 1) { const otherMainSections = uniqueSections.filter(s => ['C', 'A+', 'B+'].includes(s) && newLengths[s]); if(otherMainSections.length > 0) sectionToAdjust = this.getRandomElement(otherMainSections); else { const fallbackSections = uniqueSections.filter(s => !['Intro', 'Outro'].includes(s) && newLengths[s]); if(fallbackSections.length > 0) sectionToAdjust = this.getRandomElement(fallbackSections); else { console.warn("Cannot find suitable section to adjust further."); break; } } } const adjustment = currentTotalBars < this.targetTotalBars.min ? 4 : -4; const currentLength = newLengths[sectionToAdjust]; const newLength = currentLength + adjustment; const minLen = ['Intro', 'Outro'].includes(sectionToAdjust) ? 4 : 8; const maxLen = ['Intro', 'Outro'].includes(sectionToAdjust) ? 16 : 32; if (newLength >= minLen && newLength <= maxLen) { console.log(`Adjusting ${sectionToAdjust} from ${currentLength} to ${newLength} (Total: ${currentTotalBars}, Target: ${this.targetTotalBars.min}-${this.targetTotalBars.max})`); newLengths[sectionToAdjust] = newLength; } else { console.log(`Cannot adjust ${sectionToAdjust} further (${adjustment > 0 ? 'max' : 'min'} limit reached).`); if(adjustment < 0 && currentLength <= minLen) {console.warn('Adjustment failed (min limit)'); break;} if(adjustment > 0 && currentLength >= maxLen) {console.warn('Adjustment failed (max limit)'); break;} } iterations++; } while (iterations < MAX_ITERATIONS); this.structure.lengths = reactive(newLengths); this.structureLengthsGenerated = true; this.structureLengthsConfirmed = false; console.log("Generated lengths:", this.structure.lengths); },
                confirmSectionLengths() { if (!this.structureLengthsGenerated) return; this.structureLengthsConfirmed = true; console.log("Section lengths confirmed."); },

                // --- Navigazione ---
                startPhase3() { // Placeholder
                    if (this.currentPhase === 2 && this.structureLengthsConfirmed) {
                         this.currentPhase = 3; this.currentStep = 3.1; console.log("Moving to Phase 3, Step 3.1"); window.scrollTo(0, 0);
                         // Reset/Initialize Phase 3 state here...
                    } else { console.warn("Cannot start Phase 3: Phase 2 (Lengths) not complete."); alert("Please confirm section lengths first."); }
                },
                goBackToPhase1Context() { console.log("Going back to Phase 1.1"); this.currentPhase = 1; this.currentStep = 1.1; },
                goBackToPhase2Lengths() { // NEW Go Back for Phase 3+ Placeholders
                    if(this.currentPhase > 2) {
                         console.log("Going back to Phase 2.3");
                         this.currentPhase = 2;
                         this.currentStep = 2.3;
                    }
                 }
            },
            mounted() { console.log("Vue App Mounted! Ready for Songwriting Game V2.4 (English)."); }
        }).mount('#app');
    </script>
</body>
</html>